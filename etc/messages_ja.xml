<?xml version="1.0" encoding="UTF-8"?>

<MessageCollection xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="messagecollection.xsd">

	<Plugin>
		<ShortDescription>fb-contribプラグイン</ShortDescription>
		<Details>
			<![CDATA[
			<p>
			このプラグインは、fb-contribプロジェクトによるFindBugsディテクタを含んでいます。
			</p>
			]]>
		</Details>
	</Plugin>

	<!-- Detectors -->

	<Detector class="com.mebigfatguy.fbcontrib.collect.CollectStatistics">
		<Details>
			<![CDATA[
			<p>他のディテクタの統計情報を収集します</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.InefficientStringBuffering">
		<Details>
			<![CDATA[
			<p>StringBufferまたは、StringBuilderのappendメソッド呼び出し時の引数の文字列の結合を探します。</p>
			<pre>
				StringBuffer sb = new StringBuffer();
				sb.append(a + b);
				return sb.toString();
			</pre>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SyncCollectionIterators">
		<Details>
			<![CDATA[
			<p>Collectionsクラスから構築されたSynchronized Collectionsのiteratorsの使い方を探します。</p>
			<p>Collections.synchronizedXXXによって構築されたCollectionが、マルチスレッドセーフであるという前提で作られています。
			しかし、iteratorによるアクセスが使用されているため、それは明示的に安全ではありません。iteratorを使用する場合、手動による
			同期を行う必要があります。</p>
			<p>低速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.CyclomaticComplexity">
		<Details>
			<![CDATA[
			<p>McCabe 循環的複雑度(Cuclomatic Complexity)を測定し、基準値を超えるメソッドを報告します。
			この基準値はシステムプロパティ 'fb-contrib.cc.limit' によって設定出来ます。</p>
			<p>低速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.OverlyConcreteParameter">
		<Details>
			<![CDATA[
			<p>インタフェースやスーパークラスで定義されたメソッドのみを使用しているにも関わらず、
			そのサブクラスを使用しているパラメータを探します。
			Publicメソッドで具象クラスに依存すると、影響度の低い変更が困難となります。</p>
			<p>低速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ListIndexedIterating">
		<Details>
			<![CDATA[
			<p>イテレータを使用せず、java.util.List を整数インデックスによって反復、取得を行なっている forループを探します。
			イテレータは、Listの実装に応じてより良いアクセスを行うことが出来ます。
			しかし、より重要なことは、他のコレクション型への変更が容易になることです。</p>
			<p>中速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.UnrelatedCollectionContents">
		<Details>
			<![CDATA[
			<p>java.lang.Object以外を継承した、無関係なインターフェイスまたはクラスのオブジェクトを保持する Collectionや配列を探します。
			そのようなコレクションや配列は、脆いコードであり、型毎の位置や、 決定した型への instanceof に依存します。
			より良い設計は、別々のクラスを作成することです。
			必要とされる異なる型を定義し、コレクションや配列に、そのクラスのインスタンスを追加することです。</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.DeclaredRuntimeException">
		<Details>
			<![CDATA[
			<p>throws節で Runtime Exceptions を宣言しているメソッドを探します。
			それらは間違いではないですが、問題の例外として誤解を生むかもしれません。
			RuntimeException を宣言する場合、起こることが予想される例外のタイプであることを意味します。
			そうである場合、コード内で処理し、伝搬するべきではありません。</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ClassEnvy">
		<Details>
			<![CDATA[
			<p><em>このディテクタは、実験中であり、多くの誤検知(FUD(Fear, Uncertainty and Doubt))が発生する可能性があります。</em></p>
			<p>自身のメソッドより、他のクラスのメソッドを高い割合で使用するメソッドを探します。
			その場合、このメソッドを他のクラスに実装するほうが良い場合が多く、リファクタリングによって、元のクラスからパラメータを受け入れられるようにする必要があります。
			この報告の割合は、システムプロパティ 'fb-contrib.ce.percent' によって設定出来ます。</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.LiteralStringComparison">
		<Details>
			<![CDATA[
			<p>リテラル文字列がパラメータとして渡し、リテラル文字列と文字列とを比較するメソッドを探します。
			.equals や .compareTo メソッドをリテラル文字列自身が呼び出し、パラメータに変数を渡す場合、
			NullPointerExceptionの可能性を回避出来ます。
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.PartiallyConstructedObjectAccess">
		<Details>
			<![CDATA[
			<p>非finalメソッドの呼び出しを行う非finalクラスのコンストラクタを探します。
			これらのメソッドはオーバーライド可能なため、オーバライドされたメソッドは、部分的に構築されたオブジェクトにアクセスすることになります。
			これは、トラブルの原因になります。</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.DubiousListCollection">
		<Details>
			<![CDATA[
			<p>java.util.List が実装され、セットのような方法で使われているフィールドを探します。
			参照系の操作が線形探索を用いて行われるため、大きなリストでのパフォーマンスが悪くなります。
			対処として、これらのフィールドはセットであるべきかを判断するべきです。順序が重要である場合は、
			LinkedHashSetの使用を検討して下さい。</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ParallelLists">
		<Details>
			<![CDATA[
			<p>２つ以上の関連情報を保持するために、同じインデックスを介して、１対１で関連付けられる２つ以上のリストや配列を管理しているクラスを探します。
			それらの情報を全て保持するクラスを新たに作成し、１つのリストにそのクラスのインスタンスを格納するべきです。</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.FinalParameters">
		<Details>
			<![CDATA[
			<p>正しくパラメータに書き込みを行わないメソッドを探します。
			これを文書化を容易にするためや、JVMがこのメソッドの呼び出しを最適化出来るようにするために、
			パラメータを final定義することを検討して下さい。</p>
			<p>低速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.AbstractClassEmptyMethods">
		<Details>
			<![CDATA[
			<p>単に例外をスローするメソッドや、空のメソッドを定義している抽象化クラスを探します。
			これは抽象化クラスなので、正しいサブクラスの動作になるように、abstractとしてこのメソッドを定義するべきです。</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ManualArrayCopy">
		<Details>
			<![CDATA[
			<p>ループを使用して１配列のデータをコピーしているメソッドを探します。
			このようなコピーを行う際は、ネイティブメソッドである System.arraycopy を使用するべきです。</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.FloatingPointLoops">
		<Details>
			<![CDATA[
			<p>ループのインデックスに浮動小数点を使用しているメソッドを探します。
			浮動小数点演算は不正確であるため、ループの度に丸め誤差の問題が発生し、問題を見つけることを困難にします。
			整数インデックスを使い、インデックスから浮動小数点値を算出するべきです。</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.NonCollectionMethodUse">
		<Details>
			<![CDATA[
			<p>Collectionsインターフェイスで定義されておらず、類似のメソッドが存在するコレクションクラスのメソッドを使用しているメソッドを探します。
			例としては：<br>
			<table border="1">
				<tr><th>古いメソッド</th><th>新しいメソッド</th></tr>
				<tr><td>Hashtable.contains</td><td>Map.containsValue</td></tr>
				<tr><td>Hashtable.elements</td><td>Map.elements</td></tr>
				<tr><td>Hashtable.keys</td><td>Map.keySet</td></tr>
				<tr><td>Vector.addElement</td><td>List.add</td></tr>
				<tr><td>Vector.elementAt</td><td>List.get</td></tr>
				<tr><td>Vector.insertElementAt</td><td>List.add</td></tr>
				<tr><td>Vector.removeAllElements</td><td>List.clear</td></tr>
				<tr><td>Vector.removeElement</td><td>List.remove</td></tr>
				<tr><td>Vector.removeElementAt</td><td>List.remove</td></tr>
				<tr><td>Vector.setElementAt</td><td>List.set</td></tr>
			</table>
			</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ConfusingAutoboxedOverloading">
		<Details>
			<![CDATA[
			<p>同一の名前を持つ int、long、float、doubleパラメータを持つメソッドと、Characterパラメータを持つメソッドを探します。
			オートボクシングが 1.5 で利用可能になっているため、
			<pre>
			test('a')
			</pre>
			を実行すると、
			<pre>
			public void test(Character c)
			</pre>
			が呼び出されるのは当然と思うかもしれません。
			しかし、実際は代わりにint、long、floatまたはdouble型を持つメソッドが呼び出されます。
			</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.AbnormalFinallyBlockReturn">
		<Details>
			<![CDATA[
			<p>値を返すか、例外をスローする finally ブロックを持つメソッドを探します。
			このコードは、通常のプログラムの流れを変更し、実際のプログラムロジックを隠匿します。</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.StaticMethodInstanceInvocation">
		<Details>
			<![CDATA[
			<p>インスタンス参照を使用して、静的メソッド呼び出しを行うメソッドを探します。
			文書化の目的のため、クラス名を使用してメソッドを呼び出すことをお勧めします。
			これは注目すべき定義の変更を表すことがあります。</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SpuriousThreadStates">
		<Details>
			<![CDATA[
			<p>java.lang.Thread のインスタンス上で、 wait や notify、notifyAll を呼び出すメソッドを探します。
			スレッドの内部動作は、スレッド自身で同期することであるため、クライアントからの呼び出しは、問題のオブジェクトのスレッド状態を
			混乱させるだろうし、意図していないときにスレッドをウェイクアップ、または実行可能状態からスレッドを削除、
			似非なスレッド状態の変更の原因となります。</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.NeedlessAutoboxing">
		<Details>
			<![CDATA[
			<p>同じクラスのコンストラクタに、プリミティブラッパークラスオブジェクトを渡しているメソッドを探します。
			 検出するパターンは以下の通りです:
			<ul>
				<li>new Boolean(Boolean)</li>
				<li>new Byte(Byte)</li>
				<li>new Character(Character)</li>
				<li>new Short(Short)</li>
				<li>new Integer(Integer)</li>
				<li>new Long(Long)</li>
				<li>new Float(Float)</li>
				<li>new Double(Double)</li>
			</ul>
			</p>
			<p>すでにxがすでにボクシングクラスである "BoxedClass.valueOf（x）"への呼び出しを探します。</p>
			<p>また、BoxedClass.valueOf(myString).boxedValue()の呼び出しを探します。
			代わりにBoxedClass.parseBoxed(myString)を使用する方が簡素です。</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.UnnecessaryStoreBeforeReturn">
		<Details>
			<![CDATA[
			<p>ローカル変数に戻り値を格納したすぐ後に、そのローカル変数を返すメソッドを探します。
			単にメソッド（または割り当て）の結果を直接返す方が簡素です。</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.CopiedOverriddenMethod">
		<Details>
			<![CDATA[
			<p>スーパークラスの実装をそのままコピーしているメソッドを探します。</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ArrayBasedCollections">
		<Details>
			<![CDATA[
			<p>contains メソッドを使用する際に、マップ(Map)の keyset の項目や、セット(Set)、リスト(List)の要素に配列を使用しているメソッドを探します。
			配列に equals メソッドを定義出来ないため、おそらく望まれていない参照の比較が、それらのコレクションに使用されます。
			意図的である場合、あなたの意図を文書化するために、この場合のようなマップを使用する場合は、IdentityHashMap クラスの使用を検討して下さい。</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.OrphanedDOMNode">
		<Details>
			<![CDATA[
			<p>DOMノードを作成しますが、どのDOM文書にも追加しないメソッドを探します。</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.AbstractOverriddenMethod">
		<Details>
			<![CDATA[
			<p>スーパークラスの具象メソッドをオーバーライドし、abstractとして宣言されたメソッドを探します。
			これを行うと、すぐにスーパークラスの実装をキャストし、親クラスによって定められた規約を壊します。</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.CustomBuiltXML">
		<Details>
			<![CDATA[
			<p>連結文字列と、カスタム値によってXMLベースの文字列を構築しているメソッドを探します。
			そうすることにより、変更を検証、理解することが困難である脆いコードを作ることになります。
			Transformer.setParameter を使用することで、パラメータを設定し、実行時に変換する方法は、外部のXMLファイルを作成する良い方法です。</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.BloatedSynchronizedBlock">
		<Details>
			<![CDATA[
			<p>synchronized ブロックを使用して実装されているメソッドを探しますが、
			ブロックの先頭は、ローカル変数やメンバー変数ではない変数にアクセスし、過度に同期されます。</p>
			<p>低速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ConstantListIndex">
		<Details>
			<![CDATA[
			<p>インデックスに整数定数を使用した配列や java.util.List を実装したクラスにアクセスしているメソッドを探します。
			これは、しばしばループ変数であることが誤りですが、特定のインデックスが、特定の物事を意味する場合は、
			おそらくファーストクラスオブジェクトがコンテナのためのより良い選択になります。</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SloppyClassReflection">
		<Details>
			<![CDATA[
			<p>Looks for methods that use Class.forName("XXX") to load a class object
			for a class that is already referenced by this class. It is simpler to just use
			XXX.class, and doing so protects the integrity of this code from such transformations
			as obfuscation. Use of Class.forName should only be used when the class in question
			isn't already statically bound to this context.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ArrayWrappedCallByReference">
		<Details>
			<![CDATA[
			<p>Looks for methods that use an array of length one to pass a variable to achieve call
			by pointer ala C++. It is better to define a proper return class type that holds all
			the relevant information retrieved from the called method.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SluggishGui">
		<Details>
			<![CDATA[
			<p>Looks for methods that implement awt or swing listeners and perform time
			consuming operations. Doing these operations in the gui thread will cause the
			interface to appear sluggish and non-responsive to the user. It is better to
			use a separate thread to do the time consuming work so that the user
			has a better experience.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.NeedlessInstanceRetrieval">
		<Details>
			<![CDATA[
			<p>Looks for methods that call a method to retrieve a reference to an object,
			to use to load a constant. It is simpler and more performant to access the
			static variable directly from the class itself.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.DateComparison">
		<Details>
			<![CDATA[
			<p>一つはやるだろうというときの2つの比較を使用してDateオブジェクトの非効率的な比較を探します。
			Looks for inefficient comparison of Date objects using two comparisons when one would do.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousWaitOnConcurrentObject">
		<Details>
			<![CDATA[
			<p>Looks for calls to the wait method on mutexes defined in the java.util.concurrent
			package where it is likely that await was intended.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.JDBCVendorReliance">
		<Details>
			<![CDATA[
			<p>Looks for uses of jdbc vendor specific classes and methods making the database
			access code non portable.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.PossibleMemoryBloat">
		<Details>
			<![CDATA[
			<p>Looks for classes that maintain collections or StringBuffer/StringBuilders in
			static member variables, and that do not appear to provide a way to clear or remove
			items from these members. Such class fields are likely causes of memory bloat.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.LocalSynchronizedCollection">
		<Details>
			<![CDATA[
			<p>Looks for allocations of synchronized collections that are stored in local
			variables, and never stored in fields or returned from methods. As local variables
			are by definition thread safe, using synchronized collections in this context
			makes no sense.</p>
			<p>中速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.FieldCouldBeLocal">
		<Details>
			<![CDATA[
			<p>Looks for classes that define fields that are used in a locals only fashion,
			specifically private fields that are accessed first in each method with a
			store vs. a load.</p>
			<p>低速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.NonOwnedSynchronization">
		<Details>
			<![CDATA[
			<p>Looks for methods that synchronize on variables that are not owned by the
			current class. Doing this causes confusion when two classes use the same variable
			for their own synchronization purposes. For cleanest separation of interests, only
			synchronize on private fields of the class. Note that 'this' is not owned by
			the current class and synchronization on 'this' should be avoided as well.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.NonRecycleableTaglibs">
		<Details>
			<![CDATA[
			<p>Looks for tag libraries that are not recycleable because backing members
			of taglib attributes are set in areas besides the setter method for the attribute.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.Section508Compliance">
		<Details>
			<![CDATA[
			<p>Looks for violation of Section 508, Accessibility for People with disabilities Act.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.UseEnumCollections">
		<Details>
			<![CDATA[
			<p>Looks for use of sets and maps using enums. It is more efficient to use EnumSet or EnumMap</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SQLInLoop">
		<Details>
			<![CDATA[
			<p>Looks for the execution of sql queries inside a loop. This pattern tends to be inefficient,
			and often can be improved upon, by collecting all the keys needed for the query and issuing just
			one query using an in clause with all the keys for all the queries previously needed in the loop.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.NeedlessMemberCollectionSynchronization">
		<Details>
			<![CDATA[
			<p>Looks for classes that define private synchronized collections as static or instance
			members, that are only altered in a static initializer or constructor. Since the multithreaded
			use of this collection is read-only, the use of synchronization is unnecessary.</p>
			<p>中速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.InheritanceTypeChecking">
		<Details>
			<![CDATA[
			<p>Looks for if/else blocks where a series of them use instanceof on the same
			variable to determine what to do. If these classes are related by inheritance,
			this often is better handled through calling a single overridden method.</p>
			<p>中速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.StaticArrayCreatedInMethod">
		<Details>
			<![CDATA[
			<p>Looks for creation of arrays in methods using constant values. These arrays
			will need to be recreated each time the method is called. These arrays should probably
			be defined as static fields, instead</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.PossiblyRedundantMethodCalls">
		<Details>
			<![CDATA[
			<p>Looks for calls of the same method on the same object when that object hasn't changed.
			This often is redundant, and the second call can be removed, or combined.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.UseToArray">
		<Details>
			<![CDATA[
			<p>Looks for code that builds an array of values from a collection, by manually looping
			over the elements of the collection, and adding them to the array. It is simpler and
			cleaner to use mycollection.toArray(new type[mycollection.size()].</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.LostExceptionStackTrace">
		<Details>
			<![CDATA[
			<p>Looks for methods that catch exceptions, and then throw a different exception
			without embedding the original exception in the thrown one. Doing so, hides the real
			source of the exception, making debugging and fixing these problems difficult.</p>
			<p>中速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.UseCharacterParameterizedMethod">
		<Details>
			<![CDATA[
			<p>Looks for methods that pass single character string constants as parameters to
			methods that alternatively have an overridden method that accepts a character instead.
			It is easier for the method to handle a single character than a String.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.TailRecursion">
		<Details>
			<![CDATA[
			<p>Looks for methods that make a recursive call to itself as the last statement in the
			method. This tail recursion could be converted into a simple loop which would improve
			the performance and stack requirements.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.UnrelatedReturnValues">
		<Details>
			<![CDATA[
			<p>Looks for methods that are defined to return Object, and return different types of
			objects based on different code paths. If this method is not based on a interface or
			superclass, it is suggested to change the return type to a type that would accomodate
			all kinds of return types.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.PossibleIncompleteSerialization">
		<Details>
			<![CDATA[
			<p>Looks for classes that don't handle serialization of parent class member fields
			when the class in question is serializable but is derived from a non serializable
			classes.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousComparatorReturnValues">
		<Details>
			<![CDATA[
			<p>Looks for class that implement Comparator or Comparable, and whose compare or compareTo
			methods return constant values only, but that don't represent the three possible choice
			(a negative number, 0, and a positive number).</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SillynessPotPourri">
		<Details>
			<![CDATA[
			<p>Looks for a potpourri of small problems that do not fit into a common pattern.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.BloatedAssignmentScope">
		<Details>
			<![CDATA[
			<p><em>このディテクタは、実験中であり、多くの誤検知(FUD(Fear, Uncertainty and Doubt))が発生する可能性があります。</em></p>
			<p>Looks for assignments to variables in a scope larger than it's use. As long as the evaluation of the assignment
			does not have side effects, the assignment can be moved into the inner scope where it is used.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SpoiledChildInterfaceImplementor">
		<Details>
			<![CDATA[
			<p>Looks for classes that implement interfaces by relying on methods being
			implemented in superclasses, even though the superclass knows nothing about
			the interface being implemented by the child.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.DeletingWhileIterating">
		<Details>
			<![CDATA[
			<p>Looks for deletion of items from a collection using the remove method
			of the collection at the same time that the collection is being iterated on. If
			this occurs the iterator will become invalid and throw a ConcurrentModificationException.
			Instead, the remove should be called on the iterator itself.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.UseSplit">
		<Details>
			<![CDATA[
			<p>Looks for code that builds an array by using a StringTokenizer to break up
			a string and place individual elements into an array. It is simpler to use
			String.split instead.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousJDKVersionUse">
		<Details>
			<![CDATA[
			<p>Looks for calls to classes and methods that do not exist in the JDK for which this class is
			compiled. This can happen if you specify the -source and -target options of the javac compiler, and
			specify a target that is less than the jdk version of the javac compiler.</p>
			<p>低速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.UseAddAll">
		<Details>
			<![CDATA[
			<p>Looks for loops that transfers the contents of one collection to another. These collection sources might
			be local variables or member fields, including sets, maps key/values, lists, or arrays. It is simpler to
			just use the addAll method of the collection class. In the case where the source is an array, you can use
			Arrays.asList(array), and use that as the source to addAll.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.MethodReturnsConstant">
		<Details>
			<![CDATA[
			<p>Looks for private or static methods that only return one constant value. Since there is no
			chance for derived classes overriding this behavior, the return of a constant value
			seems dubious.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.NeedlessCustomSerialization">
		<Details>
			<![CDATA[
			<p>Looks for classes that implement the Serializable interface and implement the
			standard readObject and writeObject methods by simply deferring to the Stream
			parameter's defaultReadObject or defaultWriteObject and nothing else. As this is the
			built in behavior, these methods are not needed.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.MisleadingOverloadModel">
		<Details>
			<![CDATA[
			<p>Looks for classes that define both static and instance methods with the same name.
			As each type represents a different use model, it doesn't make sense that this name
			would be overloaded, and will confuse users of the class.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ExceptionSoftening">
		<Details>
			<![CDATA[
			<p>Looks for methods that catch checked exceptions, and throw unchecked
			exceptions in their place. There are several levels of concern. Least
			concerning are methods constrained by interface or super class contracts
			not to throw checked exceptions but appear owned by the same author. Next
			are methods constrained by interface or super class contracts and throw other
			types of checked exceptions. Most egregious are method not constrained by any interface
			or superclass contract.</p>
			<p>中速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ConfusingFunctionSemantics">
		<Details>
			<![CDATA[
			<p>Looks for methods that return a parameter after modifying that parameter.
			Doing this will confuse the user of this method, as it will be assumed that the
			passed in argument is different than the output, or at least won't be changed.
			If the purpose of this method is just to modify the parameter, this method should
			probably be changed to have a void return type. If you must return a variable, perhaps
			a clone of the parameter should be returned.
			</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.JUnitAssertionOddities">
		<Details>
			<![CDATA[
			<p>Looks for junit test case methods that use assertions with odd parameters.
			Including in this is:
			<ul>
				<li>Passing a constant as the second (actual) parameter</li>
				<li>not using the three parameter version of asserts for doubles</li>
				<li>Passing true or false as the first parameter instead of using assertTrue, or assertFalse</li>
				<li>Using the assert keyword</li>
			</ul>
			</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousCloneAlgorithm">
		<Details>
			<![CDATA[
			<p>Looks for implementations of clone where an assignment is made to a field of the
			source object. It is likely that that store should have occurred on the cloned object, as
			the clone operation is almost always considered read only.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.WeakExceptionMessaging">
		<Details>
			<![CDATA[
			<p>Looks for exceptions that are thrown with static strings as messages. Using static strings
			doesn't differentiate one use of this method versus another, and so it may be difficult
			to determine how this exception occurred without showing context.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousClusteredSessionSupport">
		<Details>
			<![CDATA[
			<p>Looks for code that fetches a complex object from an HttpSession attribute, modifies the
			object, but does not call setAttribute again on this object. This will not inform the application server
			that this object has changed, and thus will not correctly replicate these changes across the cluster.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.LoggerOddities">
		<Details>
			<![CDATA[
			<p>Looks for odd patterns of use of Logger classes from either log4j, slf4j or commons logging.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.IncorrectInternalClassUse">
		<Details>
			<![CDATA[
			<p>Looks for classes that rely on internal classes in the various apis or libraries. As these
			classes are not officially released from the api vendor, they are subject to change or removal, and thus,
			should not be counted on.</p>
			Packages that shouldn't be used are:
			<ul>
				<li>com.sun.xxx</li>
				<li>org.apache.xerces.xxx</li>
				<li>org.apache.xalan.xxx</li>
			</ul>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.DubiousSetOfCollections">
		<Details>
			<![CDATA[
			<p>Looks for sets or keySets of maps that contain other collections. As typically collections calculate
			their hashCode, equals and compareTo methods by iterating the collection and evaluating the same function
			on each item in the collection, this can be costly from a performance point of view.</p>
			<p>In addition, using a set, or keySet of a map, infers that you will be looking for items based on
			the value of a collection, which seems dubious at best.</p>
			<p>Finally, as collections are often modified, This may cause problems if the collection is modified,
			thus changing hashCodes, etc, while the collection is in the set.</p>
			<p>If you wish to keep a collection of collections, the outer collection should probably be a list
			to avoid these problems</p>
			<p>中速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.BogusExceptionDeclaration">
		<Details>
			<![CDATA[
			<p>Looks for constructors, static methods and private methods that declare that they throw
			checked exceptions that the actual code never throws. Since these methods can't be overridden,
			there is no reason to add these exceptions to the method declaration.</p>
			<p>中速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.UnnecessaryNewNullCheck">
		<Details>
			<![CDATA[
			<p>Looks for allocations of objects, and then immediately checking to see if the
			object is null, or non null. As the new operator is guaranteed to eiher succeed, or throw
			an exception, this null check is useless, and denotes a misunderstanding as to how
			the jvm works. You can remove this guard.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.DeprecatedTypesafeEnumPattern">
		<Details>
			<![CDATA[
			<p>Looks for classes that appear to implement the old style type safe enum pattern
			that was used before java added Enum support to the language. Since this class is
			compiled with java 1.5 or later, it would be simpler to just use java enums</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.StutteredMethodArguments">
		<Details> experimental="true"
			<![CDATA[
			<p>Looks for method calls that pass the same value for two separate parameters, where
			those arguments are not constants. Often this is a cut/paste mistake, but if not, it is
			confusing why you would pass the same value for two arguments.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.TristateBooleanPattern">
		<Details>
			<![CDATA[
			<p>Looks for methods that are declared to return a Boolean, but return a null
			value. As this now allows the method to return 3 values, the use of Boolean is
			dubious. It would be better to just define a new enumeration with three values,
			and return that.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousUninitializedArray">
		<Details>
			<![CDATA[
			<p>Looks for methods that return arrays that are allocated but not initialized
			in this method. While it's possible that the calling method will do the work of
			initializing the array, it is not a usual pattern, and it suspected that this array
			was just forgotten to be initialized.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.InappropriateToStringUse">
		<Details>
			<![CDATA[
			<p>Looks for methods that perform algorithmic operations on Strings that are returned
			from a toString() method. As toString should only be used for debug/trace purposes, it
			shouldn't be used for algorithm use.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.InconsistentKeyNameCasing">
		<Details>
			<![CDATA[
			<p>Looks for methods that use the same name with different casing to access objects in HttpRequest parameters
			and attributes. As these parameter names are case sensitive this will lead to confusion.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.OverzealousCasting">
		<Details>
			<![CDATA[
			<p>Looks for manual casts of objects that are more specific then needed as the value is assigned
			to a class or interface higher up in the inheritance chain. You only need to cast to that class
			or interface.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.PoorlyDefinedParameter">
		<Details>
			<![CDATA[
			<p>Looks for non derivable methods that declare parameters and then cast those
			parameters to more specific types in the method. This is misleading and dangerous
			as you are not documenting through parameter types what is necessary for these
			parameters to function correctly.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.NonSymmetricEquals">
		<Details>
			<![CDATA[
			<p>Looks for classes that break the fundamental rule of equivalence, which is
			symmetry. If a equals b, then b equals a. While it is usually wrong to allow
			equals to compare different types, at the very least you should make sure that
			each class knows about each other and is able to compare themselves with each other.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ContraVariantArrayAssignment">
		<Details>
			<![CDATA[
			<p>Finds contravariant array assignments. Since arrays are mutable data structures, their use
			must be restricted to covariant or invariant usage</p>

			<pre>
			class A {}
			class B extends A {}

			B[] b = new B[2];
			A[] a = b;
			a[0] = new A(); // results in ArrayStoreException (Runtime)
			</pre>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.NonFunctionalField">
		<Details>
			<![CDATA[
			<p>Looks for fields in serializable classes that are defined as both final and
			transient. As a transient field is not initialized when streamed, and is not
			initialized in a constructor, it will remain null because it is defined final.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousNullGuard">
		<Details>
			<![CDATA[
			<p>Looks for code that checks to see if a field or local variable is not null,
			before entering a code block either an if, or while statement, and then reassigns that
			field or local variable. It is likely that guard should have been to see if that
			field or local variable is null, not, not null</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.MoreDumbMethods">
		<Details>
			<![CDATA[
			<p>This detector looks for calls to more pointless or deprecated methods.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ReflectionOnObjectMethods">
		<Details>
			<![CDATA[
			<p>This detector looks for reflective calls on methods that are found in the class java.lang.Object.
			As these methods are always available, there is no reason to use reflection to call them.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ImproperPropertiesUse">
		<Details>
			<![CDATA[
			<p>This detector looks for java.util.Properties use where values other than String
			are placed in the properties object. As the Properties object was intended to be a
			String to String only collection, putting other types in the Properties object is
			incorrect, and takes advantage of a poor design decision by the original Properties class
			designers to derive from Hashtable, rather than using aggregation.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.PossibleConstantAllocationInLoop">
		<Details>
			<![CDATA[
			<p>This detector looks for allocations of objects using the default constructor in a loop, where
			the object allocated is never assigned to any object that is used outside the loop.
			It is possible that this allocation can be done outside the loop to avoid excessive garbage.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.WriteOnlyCollection">
		<Details>
			<![CDATA[
			<p>This detector looks for allocations and initializations of java collections, but that are never
			read from or accessed to gain information. This represents a collection of no use, and most probably
			can be removed. It is similar to a dead local store.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.UseVarArgs">
		<Details>
			<![CDATA[
			<p>This detector looks for definitions of methods that have an array as the last parameter.
			Since this class is compiled with java 1.5 or better, it would be more flexible for clients of this
			method to define this parameter as a vararg parameter</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.PossibleUnsuspectedSerialization">
		<Details>
			<![CDATA[
			<p>This detector looks for code that serializes objects that are non-static inner
			classes of other classes. Since there is a reference to the containing class, this class will be serialized as well.
			It is often the case that this is not what is wanted, and will cause much more data to be serialized
			than is necessary.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SideEffectConstructor">
		<Details>
			<![CDATA[
			<p>This detector looks for object creation where the object isn't assigned to any variable or
			field. This implies that the class operates through side effects in the constructor, which makes
			for difficult to maintain code.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.SuspiciousGetterSetterUse">
		<Details>
			<![CDATA[
			<p>This detector looks for java bean getter-setter use where the value of a property is set
			with the value retrieved from the same bean's correllary getter, like this:</p>
			<pre>
				person.setAge(person.getAge());
			</pre>
			<p>Typically this is a copy paste typo.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.LingeringGraphicsObjects">
		<Details>
			<![CDATA[
			<p>This detector looks for creation of java.awt.Graphics object that do not have the
			.dispose() method called on them when finished. These objects will be cleaned up by
			the Garbage collector, bug given the likelyhood that large numbers of these objects can
			be created in a short period of time, it is better to dispose them as soon as possible.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.StackedTryBlocks">
		<Details>
			<![CDATA[
			<p>This detector looks for two or more try catch blocks that are consecutive
			and catch the same kind of exception, and each catch block mandatorily throws
			the same exception. These two catch blocks can and should be made into one
			catch block to simply the code.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.CommonsEqualsBuilderToEquals">
		<Details>
			<![CDATA[
			<p>This detector looks for uses for Commons-lang EqualsBuilder where the
			result of equals() is returned instead of calling the method isEquals().</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.CommonsHashcodeBuilderToHashcode">
		<Details>
			<![CDATA[
			<p>This detector looks for uses for Commons-lang HashCodeBuilder where the
			result of hashCode() is returned instead of calling the method toHashCode().</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.CommonsStringBuilderToString">
		<Details>
			<![CDATA[
			<p>This detector looks for uses for Commons-lang ToStringBuilder where the
			result of toString() is returned without an intermediate invocation of toString().</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.CompareClassNameEquals">
		<Details>
			<![CDATA[
			<p>In a JVM, Two classes are the same class (and consequently the same type) if
			they are loaded by the same class loader, and they have the same fully
			qualified name [JVMSpec 1999].

			Comparing class name ignores the class loader.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.BackportReusePublicIdentifiers">
		<Details>
			<![CDATA[
			<p>Detects use of Backport Utils concurrent classes. Updated/Efficient version of these
			classes are available in versions of the JDK 5.0 and higher, and these
			classes should only be used if you are targeting JDK 1.4 and lower.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.CloneUsability">
		<Details>
			<![CDATA[
			<p>Looks for classes that implement clone() that do not specialize the return value, and do
			not swallow CloneNotSupportedException. Not doing so makes the clone method not as simple to use,
			and should be harmless to do so.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ConfusingArrayAsList">
		<Details>
			<![CDATA[
			<p>Looks for calls to Arrays.asList where the parameter is a primitive array.
			This does not produce a list that holds the primitive boxed values, but a list of
			one item, the array itself.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.PresizeCollections">
		<Details>
			<![CDATA[
			<p>Looks for methods that create collections using the default constructor,
			even though the number of elements that will be placed in the collection is known
			apriori, and thus could be pre-allocated. Not doing so just causes more intermediate
			reallocations which is unnecessary.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.UnboundMethodTemplateParameter">
		<Details>
			<![CDATA[
			<p>Looks for methods that declare method level template parameter(s) that are not bound to any of the
			method's parameters, and thus is not adding any validation/type safety to the method, and is
			just confusing.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.NonProductiveMethodCall">
		<Details>
			<![CDATA[
			<p>Looks for common methods that are non mutating where the return value is ignored. As these methods
			do not change the object they are called on, calling this methods is pointless. They can be removed.</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.ArrayIndexOutOfBounds">
		<Details>
			<![CDATA[
			<p>Looks for questionable load/stores to array elements.
			<ul>
			<li>
			Looks for accesses to array elements using literal values that are known to be outside the bounds of the array.
			This mistake will cause an ArrayIndexOutOfBoundsException to occur at runtime.</li>
			<li>
			Looks for stores to array elements where the array itself appears to have not been allocated.
			</li>
			</ul>
			</p>
			<p>高速ディテクタです。</p>
			]]>
		</Details>
	</Detector>

	<Detector class="com.mebigfatguy.fbcontrib.detect.OCSDebugger">
		<Details></Details>
	</Detector>

	<!-- BugPattern -->

	<BugPattern type="ISB_INEFFICIENT_STRING_BUFFERING">
		<ShortDescription>メソッドは StringBuffer又は StringBuilderのappendメソッドの引数の中で、文字列を単純結合をしています。</ShortDescription>
		<LongDescription>メソッド {1} は StringBuffer又は StringBuilderのappendメソッドの引数の中で、文字列を単純結合をしています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method uses StringBuffer or StringBuilder's append method to concatenate strings. However, it passes the result
			of doing a simple String concatenation to one of these append calls, thus removing any performance gains
			of using the StringBuffer or StringBuilder class.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="ISB_EMPTY_STRING_APPENDING">
		<ShortDescription>メソッドは 型変換を行うために空の文字列を結合しています。</ShortDescription>
		<LongDescription>メソッド {1} は型変換を行うために空の文字列を結合しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method concatenates an empty string with a literal value, in order to convert
			the literal value into a string. It is more efficient to use String.valueOf() to do the same
			thing as you do not incur the cost of creating a StringBuffer/Builder and calling methods on it
			to accomplish this.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="ISB_TOSTRING_APPENDING">
		<ShortDescription>メソッドは toString()を実行した結果を結合しています。</ShortDescription>
		<LongDescription>メソッド {1} はtoString()を実行した結果を結合しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method concatenates the output of a toString() call into a StringBuffer/Builder.
			It is simpler just pass the object you want to append to the to append call, as that form
			does not suffer the potential for NullPointerExceptions, and is easier to read.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SCI_SYNCHRONIZED_COLLECTION_ITERATORS">
		<ShortDescription>メソッドは 同期コレクションのイテレータを生成しています。</ShortDescription>
		<LongDescription>メソッド {1} は同期コレクションのイテレータを生成しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method uses a synchronized collection, built from Collections.synchronizedXXXX, but accesses it
			through an iterator. Since an iterator is by definition, multithreaded unsafe, this is a conflict in
			concept. When using iterators, you should do the synchronization manually.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="CC_CYCLOMATIC_COMPLEXITY">
		<ShortDescription>メソッドは 過度に複雑です。</ShortDescription>
		<LongDescription>メソッド {1} は過度に複雑です。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method has a high cyclomatic complexity figure, which calculates the number of branch
			points. It is likely difficult to test, and is brittle to change. Consider refactoring this
			method into several to reduce the risk.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="OCP_OVERLY_CONCRETE_PARAMETER">
		<ShortDescription>メソッドは 不必要に具象クラスをパラメータに定義しています。</ShortDescription>
		<LongDescription>メソッド {1} は不必要に具象クラスをパラメータに定義しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method uses concrete classes for parameters when only methods defined in an implemented
			interface or super class are used. Consider increasing the abstraction of the interface to
			make low impact changes easier to accomplish in the future.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="LII_LIST_INDEXED_ITERATING">
		<ShortDescription>メソッドは リストを反復処理するために、整数インデックスの forループを使用しています。</ShortDescription>
		<LongDescription>メソッド {1} はリストを反復処理するために、整数インデックスの forループを使用しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method uses an integer based for loop to iterator over a java.util.List, by calling
			List.get(i) each time thru the loop. The integer is not used for other reasons. It is better
			to use an Iterator instead, as depending on List implementation, iterators can perform better,
			and they also allow for exchanging of other collection types without issue.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="UCC_UNRELATED_COLLECTION_CONTENTS">
		<ShortDescription>メソッドは コレクションや配列に、無関係な型を追加しています。</ShortDescription>
		<LongDescription>メソッド {1} はコレクションや配列に、無関係な型を追加しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method adds unrelated objects to a collection or array, requiring careful and brittle
			data access to that collection. Create a separate class with properties needed, and add
			an instance of this class to the collection or array, if possible.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="DRE_DECLARED_RUNTIME_EXCEPTION">
		<ShortDescription>メソッドが throws節に RuntimeException を宣言しています。</ShortDescription>
		<LongDescription>メソッド {1} が throws節に RuntimeException を宣言しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method declares a RuntimeException derived class in it's throws clause.
			This may indicate a misunderstanding as to how unchecked exceptions are handled.
			If is felt that a RuntimeException is so prevalent that it should be declared, it
			is probably a better idea to prevent the occurance in code.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="CE_CLASS_ENVY">
		<ShortDescription>メソッドは 他のクラスのメソッドを過度に使用しています。</ShortDescription>
		<LongDescription>メソッド {1} は他のクラスのメソッドを過度に使用しています。</LongDescription>
		<Details>
			<![CDATA[
			<p><em>このディテクタは、実験中であり、多くの誤検知(FUD(Fear, Uncertainty and Doubt))が発生する可能性があります。</em></p>
			<p>This method makes extensive use of methods from another class over methods of it's own
			class. Typically this means that the functionality that is accomplished by this method
			most likely belongs with the class that is being used so liberally. Consider refactoring this
			method to be contained in that class, and to accept all the parameters needed in the method signature.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="LSC_LITERAL_STRING_COMPARISON">
		<ShortDescription>メソッドは リテラル文字列との比較に、リテラル文字列を引数として渡しています。</ShortDescription>
		<LongDescription>メソッド {1} は、リテラル文字列との比較に、リテラル文字列を引数として渡しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls the equals or compareTo methods on a String variable passing in a String literal.
			A NullPointerException may occur if the string variable is null. If instead the method was called on
			the string literal, and the variable was passed as an argument, this exception could never happen.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="PCOA_PARTIALLY_CONSTRUCTED_OBJECT_ACCESS">
		<ShortDescription>コンストラクタは非finalメソッドへの呼び出しを行なっています。</ShortDescription>
		<LongDescription>コンストラクタ {1} は非finalメソッドへの呼び出しを行なっています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This constructor makes a call to a non-final method. Since this method can be overriden, a subclasses
			implementation will be executing against an object that has not been initialized at the subclass level.
			You should mark all methods called from the constructor as final to avoid this problem.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="DLC_DUBIOUS_LIST_COLLECTION">
		<ShortDescription>クラスはリスト(Listクラス)ベースのフィールドを定義していますが、それらはセット(Setクラス)のように使用されています。</ShortDescription>
		<LongDescription>クラス {0} はリスト(Listクラス)ベースのフィールドを定義していますが、それらはセット(Setクラス)のように使用されています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This class defines a field based on java.util.List, but uses it to some extent like a Set. Since
			lookup type operations are performed using a linear search for Lists, the performance for large
			Lists will be poor. Consider changing this fields implementation to a set based one. If order of
			iteration is important to maintain insert order, perhaps consider a LinkedHashSet.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="PL_PARALLEL_LISTS">
		<ShortDescription>クラスはそれぞれが関連しあうリストや配列を２つ以上定義しています。</ShortDescription>
		<LongDescription>クラス {0} はそれぞれが関連しあうリストや配列を２つ以上定義しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This class appears to maintain two or more lists or arrays who's contains is related one-for-one
			through the index of the list or array. Consider creating a separate class to hold all the related
			pieces of information, and adding instances of this class to just one list or array, or if just two values, use
			a Map to associate one value with the other.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="FP_FINAL_PARAMETERS">
		<ShortDescription>メソッドは final としてパラメータを定義していませんが、finalにすることは可能です。</ShortDescription>
		<LongDescription>メソッド {1} は final としてパラメータを定義していませんが、finalにすることは可能です。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method correctly does not write to a parameter. To help document this, and to perhaps
			help the jvm optimize the invocation of this method, you should consider defining these parameters
			as final.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="ACEM_ABSTRACT_CLASS_EMPTY_METHODS">
		<ShortDescription>空のメソッドは abstractとして宣言出来ます。</ShortDescription>
		<LongDescription>空のメソッド {1} は abstractとして宣言出来ます。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method is empty or merely throws an exception. Since the class it is defined in is
			abstract, it may be more correct to define this method as abstract instead, so that proper
			subclass behavior is enforced.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="MAC_MANUAL_ARRAY_COPY">
		<ShortDescription>メソッドは 配列を手動でコピーしています。</ShortDescription>
		<LongDescription>メソッド {1} は配列を手動でコピーしています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method copies data from one array to another manually using a loop.
			It is much better performing to use System.arraycopy as this method is native.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="FPL_FLOATING_POINT_LOOPS">
		<ShortDescription>メソッドは 浮動小数点インデックスのループを使用しています。</ShortDescription>
		<LongDescription>メソッド {1} は浮動小数点インデックスのループを使用しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method uses floating point variables to index a loop. Since floating point
			math is imprecise, rounding errors will accumulate over time each time the loop is
			executed. It is usually better to use integer indexing, and calculate the new value
			of the floating point number at the top of the loop body.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NCMU_NON_COLLECTION_METHOD_USE">
		<ShortDescription>メソッドは 古い非コレクションインターフェイスメソッドを使用しています。</ShortDescription>
		<LongDescription>メソッド {1} は古い非コレクションインターフェイスメソッドを使用しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method makes calls to collection classes where the method is not defined by the Collections
			interface, and an equivalent method exists in the interface. By using the new methods,
			you can define this object by the Collections interface and allow better decoupling.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="CAO_CONFUSING_AUTOBOXED_OVERLOADING">
		<ShortDescription>クラスは 数値パラメータを持つメソッドと、文字パラメータを持つメソッドを混在して定義しています。</ShortDescription>
		<LongDescription>クラス {0} は 数値パラメータを持つメソッドと、文字パラメータを持つメソッドを混在して定義しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This class defines two methods that differ only by a parameter being defined
			as Character vs. int, long, float or double. As autoboxing is present, it may be
			assumed that a parameter of 'a' would map to the Character version, but does not.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="AFBR_ABNORMAL_FINALLY_BLOCK_RETURN">
		<ShortDescription>クラスは finallyブロック内で異常な終了をする処理を保有しています。</ShortDescription>
		<LongDescription>クラス {0} は finallyブロック内で異常な終了をする処理を保有しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method returns or throws exceptions from a finally block. This will
			mask real program logic in the try block, and short-circuit normal method termination.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SMII_STATIC_METHOD_INSTANCE_INVOCATION">
		<ShortDescription>メソッドは インスタンスの静的メソッドを呼び出しています。</ShortDescription>
		<LongDescription>メソッド {1} はインスタンスの静的メソッドを呼び出しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method makes a static method call on an instance reference. For
			reading comprehension of the code is better to call the method on the class,
			rather than an instance. Perhaps this method's static nature has changed since
			this code was written, and should be revisited.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="STS_SPURIOUS_THREAD_STATES">
		<ShortDescription>メソッドは スレッドインスタンス上で wait、notify又は notifyAll メソッドを呼び出しています。</ShortDescription>
		<LongDescription>メソッド {1} はスレッドインスタンス上で wait、notify又は notifyAll メソッドを呼び出しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method invokes the methods wait, notify or notifyAll on a Thread instance.
			Doing so will confuse the internal thread state behaviour causing spurious thread
			wakeups/sleeps because the internal mechanism also uses the thread instance for it's
			notifications.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NAB_NEEDLESS_AUTOBOXING_CTOR">
		<ShortDescription>メソッドは プリミティブラッパークラスのコンストラクタに、同じプリミティブクラスのインスタンスを渡しています。</ShortDescription>
		<LongDescription>メソッド {1} はプリミティブラッパークラスのコンストラクタに、同じプリミティブクラスのインスタンスを渡しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method passes a wrapped primitive object to the same class's constructor.
			Since wrapper classes are immutable, you can just use the original object, rather
			than constructing a new one. This code works because of an abuse of autoboxing.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NAB_NEEDLESS_BOXING_STRING_CTOR">
		<ShortDescription>メソッドは プリミティブラッパーコンストラクタへパースされた文字列を渡しています。</ShortDescription>
		<LongDescription>メソッド {1} はプリミティブラッパーコンストラクタへパースされた文字列を渡しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method passes a primitive value retrieved from a BoxedPrimitive.parseBoxedPrimitive("1") call to
			the same class's constructor. It is simpler to just pass the string to the BoxedPrimitives constructor.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NAB_NEEDLESS_AUTOBOXING_VALUEOF">
		<ShortDescription>メソッドは ラッパークラスの valueOf メソッドへプリミティブラッパーを渡しています。</ShortDescription>
		<LongDescription>メソッド {1} はラッパークラスの valueOf メソッドへプリミティブラッパーを渡しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method passes a wrapped primitive object to the same class's .valueOf method.
			Since wrapper classes are immutable, you can just use the original object, rather
			than calling valueOf to create a new one. This code works because of an abuse of autoboxing.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NAB_NEEDLESS_BOXING_PARSE">
		<ShortDescription>メソッドは 過度のボクシングを使用し、文字列からプリミティブに変換しています。</ShortDescription>
		<LongDescription>メソッド {1} は過度のボクシングを使用し、文字列からプリミティブに変換しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method passes a String to a wrapped primitive object's valueOf method, which in turn calls
			the boxedValue() method to convert to a primitive. When it is desired to convert from a String
			to a primitive value, it is simpler to use the BoxedPrimitive.parseBoxedPrimitive(myString)
			method. </p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NAB_NEEDLESS_BOXING_VALUEOF">
		<ShortDescription>メソッドは 過度のボクシングを使用し、文字列からボックスプリミティブに変換しています。</ShortDescription>
		<LongDescription>メソッド {1} は過度のボクシングを使用し、文字列からボックスプリミティブに変換しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method passes a String to a wrapped primitive object's parse method, which in turn calls
			the valueOf() method to convert to a boxed primitive. When it is desired to convert from a String
			to a boxed primitive object, it is simpler to use the BoxedPrimitive.valueOf(myString)
			method.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NAB_NEEDLESS_BOX_TO_UNBOX">
		<ShortDescription>メソッドは プリミティブ値を取得するためだけに、プリミティブからボックスプリミティブを生成しています。</ShortDescription>
		<LongDescription>メソッド {1} はプリミティブ値を取得するためだけに、プリミティブからボックスプリミティブを生成しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method constructs a Boxed Primitive from a primitive only to call the primitiveValue() method to
			convert it back to a primitive. Just use the primitive value instead.</p>
			<pre>
				primitive i = new BoxedPrimitive(1).primitiveValue();
			</pre>
			or
			<pre>
				primitive i = BoxedPrimitive.valueOf(1).primitiveValue();
			</pre>
			should just use
			<pre>
				primitive i = 1;
			</pre>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NAB_NEEDLESS_BOX_TO_CAST">
		<ShortDescription>メソッドは 他のプリミティブ型へキャストするためだけに、ボックスプリミティブを生成しています。</ShortDescription>
		<LongDescription>メソッド {1} は他のプリミティブ型へキャストするためだけに、ボックスプリミティブを生成しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method constructs a Boxed Primitive from a primitive only to call the primitiveValue() method to
			cast the value to another primitive typee. It is simpler to just use casting</p>
			<pre>
				primitive i = new BoxedPrimitive(1.0).primitiveValue();
			</pre>
			or
			<pre>
				primitive i = BoxedPrimitive.valueOf(1.0).primitiveValue();
			</pre>
			should just use
			<pre>
				primitive i = (primitive)1.0;
			</pre>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NAB_NEEDLESS_BOOLEAN_CONSTANT_CONVERSION">
		<ShortDescription>メソッドは 不必要にブール定数をボックスしています。</ShortDescription>
		<LongDescription>メソッド {1} は不必要にブール定数をボックスしています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method assigns a Boxed boolean constant to a primitive boolean variable, or assigns a primitive boolean
			constant to a Boxed boolean variable. Use the correct constant for the variable desired. Use</p>
			<pre>
				boolean b = true;
				boolean b = false;
			</pre>
			or
			<pre>
				Boolean b = Boolean.TRUE;
				Boolean b = Boolean.FALSE;
			</pre>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="USBR_UNNECESSARY_STORE_BEFORE_RETURN">
		<ShortDescription>メソッドは 結果を返す直前に、結果をローカル変数に格納しています。</ShortDescription>
		<LongDescription>メソッド {1} は結果を返す直前に、結果をローカル変数に格納しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method stores the return result in a local variable, and then immediately
			returns the local variable. It would be simpler just to return the value that is
			assigned to the local variable, directly.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="COM_COPIED_OVERRIDDEN_METHOD">
		<ShortDescription>メソッドは スーパークラスのメソッドと同一内容で実装されています。</ShortDescription>
		<LongDescription>メソッド {1} はスーパークラスのメソッドと同一内容で実装されています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method is implemented using an exact copy of it's super class method's
			implementation, which usually means that this method can just be removed.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="ABC_ARRAY_BASED_COLLECTIONS">
		<ShortDescription>メソッドは コレクションの基礎として配列を使用しています。</ShortDescription>
		<LongDescription>メソッド {1} はコレクションの基礎として配列を使用しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method passes an array as the key to a Map, element in a Set, or item in a List when
			the contains method is used on the List. Since arrays do not, and cannot override the equals
			method, collection inclusion is based on the reference's address, which is probably not desired.
			In the case that this is a TreeMap or TreeSet, consider passing a Comparator to the map's
			constructor.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="ODN_ORPHANED_DOM_NODE">
		<ShortDescription>メソッドは ドキュメントにアタッチしていないDOMノードを生成しています。</ShortDescription>
		<LongDescription>メソッド {1} はドキュメントにアタッチしていないDOMノードを生成しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>このメソッドはドキュメントにアタッチしていないDOMノードを生成しています。</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="AOM_ABSTRACT_OVERRIDDEN_METHOD">
		<ShortDescription>抽象的なメソッドが具体的な実装をオーバーライドしています。</ShortDescription>
		<LongDescription>抽象的なメソッド {1} が具体的な実装をオーバーライドしています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This abstract method is derived from a concrete method implementation. It is highly
			suspect that the super class method's implementation would be cast away.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="CBX_CUSTOM_BUILT_XML">
		<ShortDescription>メソッドは アドホックな結合でXML文字列を生成しています。</ShortDescription>
		<LongDescription>メソッド {1} はアドホックな結合でXML文字列を生成しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method generates an xml based string by concatenating together various
			xml fragments, and variable values. Doing so makes the code difficult to read, modify
			and validate. It is much more clean to built xml structures in external files that are
			read in and transformed into the final product, thru modification by Transformer.setParameter.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="BSB_BLOATED_SYNCHRONIZED_BLOCK">
		<ShortDescription>メソッドは コードのブロックを過度に同期しています。</ShortDescription>
		<LongDescription>メソッド {1} はコードのブロックを過度に同期しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This methods implements a synchronized block, but the code found at the beginning
			of this block only accesses local variables, and not member variables, or this.
			To be better performance move the code that access local variables only, above the
			synchronized block, and leave the synchronized block only for field accesses, or access
			to this object.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="CLI_CONSTANT_LIST_INDEX">
		<ShortDescription>メソッドは 定数インデックスでリストや配列にアクセスしています。</ShortDescription>
		<LongDescription>メソッド {1} は定数インデックスでリストや配列にアクセスしています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method accesses an array or list using a constant integer index. Often,
			this is a typo where a loop variable is intended to be used. If however, specific
			list indices mean different specific things, then perhaps replacing the list with
			a first-class object with meaningful accessors would make the code less brittle.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SCR_SLOPPY_CLASS_REFLECTION">
		<ShortDescription>メソッドは Class.forName を使い、静的にバインドされたクラスにアクセスしています。</ShortDescription>
		<LongDescription>メソッド {1} はClass.forName を使い、静的にバインドされたクラスにアクセスしています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method accesses the class object of a class that is already statically bound
			in this context, with Class.forName. Using Class.forName makes reflection more fragile
			in regards to code transformations such as obfuscation, and is unneeded here, since
			the class in question is already 'linked' to this class.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="AWCBR_ARRAY_WRAPPED_CALL_BY_REFERENCE">
		<ShortDescription>メソッドは 参照によるアクセスをシミュレートするために、１要素の配列を使用しています。</ShortDescription>
		<LongDescription>メソッド {1} は参照によるアクセスをシミュレートするために、１要素の配列を使用しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method uses a one element array to wrap an object that is to be passed to a method as an argument
			to simulate call by pointer ala C++. It is better to define a proper return class type that holds all
			the relevant information retrieved from the called method.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SG_SLUGGISH_GUI">
		<ShortDescription>メソッドは GUIスレッドで時間のかかる操作を実行しています。</ShortDescription>
		<LongDescription>メソッド {1} はGUIスレッドで時間のかかる操作を実行しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method implements an awt or swing listener and performs time
			consuming operations. Doing these operations in the gui thread will cause the
			interface to appear sluggish and non-responsive to the user. Consider
			using a separate thread to do the time consuming work so that the user
			has a better experience.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NIR_NEEDLESS_INSTANCE_RETRIEVAL">
		<ShortDescription>メソッドは 静的メンバーを取得するために、インスタンスを取得しています。</ShortDescription>
		<LongDescription>メソッド {1} は静的メンバーを取得するために、インスタンスを取得しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls a method to load a reference to an object, and then only
			uses it to load a static member of that instance's class. It is simpler and
			better performant to just load the static field from the class itself.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="DDC_DOUBLE_DATE_COMPARISON">
		<ShortDescription>メソッドは 日付の比較を行う際に、２つの日付比較を使用しています。</ShortDescription>
		<LongDescription>メソッド {1} は日付の比較を行う際に、２つの日付比較を使用しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method compares dates with two comparisons, rather than using the reverse comparison.
			So This pattern</p>
			<pre>
				if ((date1.equals( date2 )) || (date1.after( date2 )))
			</pre>
			could become
			<pre>
				if (date1.compareTo( date2 ) >= 0)
			</pre>
			and
			<pre>
				if ((date1.equals( date2 )) || (date1.before( date2 )))
			</pre>
			could become
			<pre>
				if (date1.compareTo( date2 ) <= 0)
			</pre>
			and
			<pre>
				if ((date1.before( date2 )) || (date1.after( date2 )))
			</pre>
			could become
			<pre>
				if (!date1.equals( date2 ))
			</pre>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SWCO_SUSPICIOUS_WAIT_ON_CONCURRENT_OBJECT">
		<ShortDescription>メソッドは awaitが意図されたであろう場合に、waitを呼び出しています。</ShortDescription>
		<LongDescription>メソッド {1} は awaitが意図されたであろう場合に、waitを呼び出しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls wait() on a on mutex defined in the java.util.concurrent package.
			These classes, define await, instead of wait, and it is most likely that await
			was intended.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="JVR_JDBC_VENDOR_RELIANCE">
		<ShortDescription>メソッドは JDBCベンダーの特定のクラスとメソッドを使用しています。</ShortDescription>
		<LongDescription>メソッド {1} はJDBCベンダーの特定のクラスとメソッドを使用しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method uses jdbc vendor specific classes and method to perform database work.
			This makes the code specific to this vendor, and unable to run on other databases.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="PMB_POSSIBLE_MEMORY_BLOAT">
		<ShortDescription>クラスはメモリ確保を肥大化させるために出現する静的なフィールドを定義しています。</ShortDescription>
		<LongDescription>クラス {0} はメモリ確保を肥大化させるために出現する静的なフィールドを定義しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>このクラスは初期化やサイズを縮められないコレクションや StringBuffer を静的フィールドに定義しています。
			これはメモリ使用量の肥大化の潜在的な原因となります。</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="LSYC_LOCAL_SYNCHRONIZED_COLLECTION">
		<ShortDescription>メソッドは 同期コレクションをローカル変数ベースで生成しています。</ShortDescription>
		<LongDescription>メソッド {1} は同期コレクションをローカル変数ベースで生成しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method creates a synchronized collection and store the reference to it
			in a local variable. As local variables are by definition threadsafe, it seems
			questionable that this collection needs to be synchronized.</p>
			<p>
			<table>
				<tr><th>If you are using</th><th>consider using</th></tr>
				<tr><td>java.util.Vector</td><td>java.util.ArrayList</td></tr>
				<tr><td>java.util.Hashtable</td><td>java.util.HashMap</td></tr>
				<tr><td>java.lang.StringBuffer</td><td>java.lang.StringBuilder</td></tr>
			</table>
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="FCBL_FIELD_COULD_BE_LOCAL">
		<ShortDescription>クラスはローカル変数としてしか使用されていないフィールドを定義しています。</ShortDescription>
		<LongDescription>クラス {1} はローカル変数としてしか使用されていないフィールドを定義しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This class defines fields that are used in a locals only fashion,
			specifically private fields or protected fields in final classes that are accessed
			first in each method with a store vs. a load. This field could be replaced by one
			or more local variables.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NOS_NON_OWNED_SYNCHRONIZATION">
		<ShortDescription>クラスは同期させるために自身が所有していない変数を使用しています。</ShortDescription>
		<LongDescription>クラス {0} は同期させるために自身が所有していない変数を使用しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method uses a synchronize block where the object that is being synchronized on,
			is not owned by this current instance. This means that other instances may use this same
			object for synchronization for its own purposes causing synchronization confusion. It is
			always cleaner and safer to only synchronize on private fields of this class. Note that 'this'
			is not owned by the current instance, but is owned by whomever assigns it to a field of its
			class. Synchronizing on 'this' is also not a good idea.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NRTL_NON_RECYCLEABLE_TAG_LIB">
		<ShortDescription>タグライブラリは再利用出来ません。</ShortDescription>
		<LongDescription>タグライブラリ {0} は再利用出来ません。</LongDescription>
		<Details>
			<![CDATA[
			<p>This Tag library class implements an attribute who's associated backing store field
			is modified at another point in the tag library. In order for a taglibrary to be
			recycleable, only the container is allowed to change this attribute, through the use
			of the setXXX method of the taglib. By modifying the value programmatically, the
			container will not initialize the attribute correctly on reuse.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="S508C_NULL_LAYOUT">
		<ShortDescription>GUI は絶対レイアウトを使用しています。</ShortDescription>
		<LongDescription>GUI {0} は絶対レイアウトを使用しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This class passes null to setLayout, which specifies that components are
			to be laid out using absolute coordinates. This makes making changes for
			font sizes, etc, difficult as items will not reposition.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="S508C_NO_SETLABELFOR">
		<ShortDescription>JLabel は貼り付けられるか指定していません。</ShortDescription>
		<LongDescription>JLabel のメソッド {1} は貼り付けられるか指定していません。</LongDescription>
		<Details>
			<![CDATA[
			<p>This class uses JLabels that do not specify what fields are being labeled.
			This hampers screen readers from given appropriate feed back to users. Use
			the JLabel.setLabelFor method to accomplish this.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="S508C_NO_SETSIZE">
		<ShortDescription>ウィンドウは packメソッドを使用せずに、手動でサイズを設定しています。</ShortDescription>
		<LongDescription>ウィンドウ {0} は packメソッドを使用せずに、手動でサイズを設定しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This class creates a window, and sizes the window using setSize. It is better
			to handle font size changes to use the pack method.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="S508C_NON_ACCESSIBLE_JCOMPONENT">
		<ShortDescription>クラスは JComponent を拡張していますが、Accessibleインターフェイスを実装していません。</ShortDescription>
		<LongDescription>クラス {0} は JComponent を拡張していますが、Accessibleインターフェイスを実装していません。</LongDescription>
		<Details>
			<![CDATA[
			<p>This class extends the JComponent gui control but does not implement the Accessibility interface.
			This makes this control unable to be processed by screen readers, etc, for people with reading/vision
			difficulties</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="S508C_SET_COMP_COLOR">
		<ShortDescription>メソッドは コンポーネントの色を明示的に設定しています。</ShortDescription>
		<LongDescription>メソッド {1} はコンポーネントの色を明示的に設定しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method sets a Components explicitly foreground or background color which may
			cause difficulty with people with vision problems from using this application.
			Colors should be allowed to be set from the operating system.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="S508C_NON_TRANSLATABLE_STRING">
		<ShortDescription>メソッドは コンポーネントのタイトル/ラベルに定数文字列を渡しています。</ShortDescription>
		<LongDescription>メソッド {1} はコンポーネントのタイトル/ラベルに定数文字列を渡しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method creates a component and passes a string literal to the title or label
			of the component. As this string will be shown to users, it should be internationalizable
			through the use of a resource bundle.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="S508C_APPENDED_STRING">
		<ShortDescription>メソッドは コンポーネントのタイトル/ラベルに文字列を付加し渡しています。</ShortDescription>
		<LongDescription>メソッド {1} はコンポーネントのタイトル/ラベルに文字列を付加し渡しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method creates a component and passes a string that was build up from a number of
			strings through appending multiple strings together. As foreign languages may order phrases
			differently, this will make translations difficult.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="UEC_USE_ENUM_COLLECTIONS">
		<ShortDescription>クラスはEnumクラスのセット(Setクラス)やマップ(Mapクラス)のキーとして、ordinary値を使用しています。</ShortDescription>
		<LongDescription>クラス {0} はEnumクラスのセット(Setクラス)やマップ(Mapクラス)のキーとして、ordinary値を使用しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This class uses an ordinary set or map collection and uses an enum class as the key type.
			It is better performant to use the jdk 1.5 EnumSet or EnumMap classes.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SIL_SQL_IN_LOOP">
		<ShortDescription>メソッドは ループ内でSQLクエリを実行しています。</ShortDescription>
		<LongDescription>メソッド {1} はループ内でSQLクエリを実行しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method executes sql queries inside of a loop. This pattern is often inefficient
			as the number of queries may mushroom in fencepost cases. It is probably more performant
			to loop over the input and collect the key data needed for the query for all items, and
			issue one query using an in clause, or similar construct, and then loop over this result
			set, and fetch all the data at once.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NMCS_NEEDLESS_MEMBER_COLLECTION_SYNCHRONIZATION">
		<ShortDescription>クラスはメンバコレクションの不必要な同期を定義しています。</ShortDescription>
		<LongDescription>クラス {0} はメンバコレクションの不必要な同期を定義しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This class defines a private collection member as synchronized. It appears however
			that this collection isn't only modified in a static initializer, or constructor. As these
			two areas are guaranteed to be thread safe, defining this collection as synchronized is
			unnecessary and a potential performance bottleneck.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="ITC_INHERITANCE_TYPE_CHECKING">
		<ShortDescription>メソッドは 仲介ロジックのために複数の instanceof オペレータを使用しています。</ShortDescription>
		<LongDescription>メソッド {1} は仲介ロジックのために複数の instanceof オペレータを使用しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method uses the instanceof operator in a series of if/else statements to
			differentiate blocks of code based on type. If these types are related by inheritance,
			it is cleaner to just define a method in the base class, and use overridden methods
			in these classes.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SACM_STATIC_ARRAY_CREATED_IN_METHOD">
		<ShortDescription>メソッドは 定数を使用して配列を生成しています。</ShortDescription>
		<LongDescription>メソッド {1} は定数を使用して配列を生成しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method creates an array initialized by constants. Each time this method is called
			this array will be recreated. It would be more performant to define the array as a
			static field of the class instead.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="PRMC_POSSIBLY_REDUNDANT_METHOD_CALLS">
		<ShortDescription>メソッドは 繰り返して同じオブジェクトの同じメソッドを呼び出しているようです。</ShortDescription>
		<LongDescription>メソッド {1} は繰り返して同じオブジェクトの同じメソッドを呼び出しているようです。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method makes two consecutive calls to the same method using the same constant
			parameters, on the same instance without any intervening changes to the objects. If this
			method does not make changes to the object, which it appears it doesn't, then making
			two calls is just a waste. These method calls could be combined by assigning the
			result into a temporary, and using the temporary the second time.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="UTA_USE_TO_ARRAY">
		<ShortDescription>メソッドは コレクションから配列を手動で生成しています。</ShortDescription>
		<LongDescription>メソッド {1} はコレクションから配列を手動で生成しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method manually loops over a collection, pulling each element out and storing
			it in an array to build an array from the collection. It is easier, and clearer to use
			the built in collections method toArray. Given a collection 'mycollection' of type T, use
			mycollection.toArray(new T[mycollection.size()]);</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="LEST_LOST_EXCEPTION_STACK_TRACE">
		<ShortDescription>メソッドは catchブロックから代替例外を履歴なしでスローしています。</ShortDescription>
		<LongDescription>メソッド {1} はcatchブロックから代替例外を履歴なしでスローしています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method catches an exception, and throws a different exception, without incorporating the
			original exception. Doing so hides the original source of the exception making debugging and fixing
			these problems difficult. It is better to use the constructor of this new exception that takes an
			original exception so that this detail can be passed along to the user.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="UCPM_USE_CHARACTER_PARAMETERIZED_METHOD">
		<ShortDescription>メソッドは １文字の定数文字列を char型パラメータを持つメソッドに渡しています。</ShortDescription>
		<LongDescription>メソッド {1} は１文字の定数文字列を char型パラメータを持つメソッドに渡しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method passes a constant literal String of length 1 as a parameter to a method, that
			exposes a similar method that takes a character. It is simpler and more expedient to handle one
			character, rather than pass a string.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="TR_TAIL_RECURSION">
		<ShortDescription>メソッドは 末尾再帰を使用しています。</ShortDescription>
		<LongDescription>メソッド {1} は末尾再帰を使用しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method recursively calls itself as the last statement of the method
			(Tail Recursion). This method can be easily refactored into a simple loop, which
			will make it more performant, and reduce the stack size requirements.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="URV_UNRELATED_RETURN_VALUES">
		<ShortDescription>メソッドは 無関係な様々な型のオブジェクトを返します。</ShortDescription>
		<LongDescription>メソッド {1} は無関係な様々な型のオブジェクトを返します。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method returns two or more unrelated types of objects (Related only through java.lang.Object).
			This will be very confusing to the code that must call it.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="URV_CHANGE_RETURN_TYPE">
		<ShortDescription>メソッドは 宣言されたよりもオブジェクトの具体的な型を返します。</ShortDescription>
		<LongDescription>メソッド {1} は宣言されたよりもオブジェクトの具体的な型を返します。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method is defined to return a java.lang.Object. However, the return types
			returned from this method can be defined by a more specific class or interface. Since this
			method is not derived from a superclass or interface, it would be more clear to
			change the return type of this method.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="URV_INHERITED_METHOD_WITH_RELATED_TYPES">
		<ShortDescription>継承されたメソッドは宣言されたよりもオブジェクトの具体的な型を返します。</ShortDescription>
		<LongDescription>継承されたメソッド {1} は宣言されたよりもオブジェクトの具体的な型を返します。</LongDescription>
		<Details>
			<![CDATA[
			<p>This inherited method is defined to return a java.lang.Object. However, the return types returned
			from this method can be defined by a more specific class or interface. If possible consider changing the
			return type in the inheritance hierarchy of this method, otherwise the caller of this method will be brittle
			in handling of the return type.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="PIS_POSSIBLE_INCOMPLETE_SERIALIZATION">
		<ShortDescription>クラスはスーパークラスのフィールドをシリアライズしていません。</ShortDescription>
		<LongDescription>クラス {0} はスーパークラスのフィールドをシリアライズしていません。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method implements Serializable but is derived from a
			class that does not. The super class has fields that are not serialized
			because this class does not take the responsibility of writing these fields out
			either using Serializable's writeObject method, or Externalizable's writeExternal
			method. Therefore when this class is read from a stream, the superclass fields
			will only be initialized to the values specified in it's default constructor.
			If possible, change the superclass to implement Serializable, or implement
			Serializable or Externalizable methods in the child class.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SC_SUSPICIOUS_COMPARATOR_RETURN_VALUES">
		<ShortDescription>Comparator メソッドが全ての順序の値を返しているように見えません。</ShortDescription>
		<LongDescription>Comparator メソッド {1} が全ての順序の値を返しているように見えません。</LongDescription>
		<Details>
			<![CDATA[
			<p>This compareTo or compare method returns constant values for to represent less than,
			equals and greater than. However it does not return each type. Given that comparators
			are transitive, this seems incorrect.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_NEGATIVE_BITSET_ITEM">
		<ShortDescription>メソッドは サポートしていない BitSet に対して負の数を bit として渡しています。</ShortDescription>
		<LongDescription>メソッド {1} は、サポートしていない BitSet に対して負の数を bit として渡しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method passes a constant negative value as a bit position to a java.util.BitSet. The BitSet class
			doesn't support negative values, and thus this method call will not work as expected.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_INTERN_ON_CONSTANT">
		<ShortDescription>メソッドは 定数文字列の intern メソッドを呼んでいます。</ShortDescription>
		<LongDescription>メソッド {1} は定数文字列の intern メソッドを呼んでいます。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls intern on a constant string. As constant strings are already interned, this call
			is superfluous</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_NO_CHAR_SB_CTOR">
		<ShortDescription>メソッドが、StringBuffer や StringBuilder の整数コンストラクタに対して 文字を渡しているように見えます。</ShortDescription>
		<LongDescription>メソッド {1} が、StringBuffer や StringBuilder の整数コンストラクタに対して 文字を渡しているように見えます。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method constructs a StringBuffer or a StringBuilder using the constructor that takes an integer, but
			appears to pass a character instead. It is probable that the author assumed that character would be appended to the
			StringBuffer/Builder, but instead the integer value of the character is used as an initial size for the buffer.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_USE_MATH_CONSTANT">
		<ShortDescription>メソッドは 非標準な数学定数を使用しています。</ShortDescription>
		<LongDescription>メソッド {1} は非標準な数学定数を使用しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method defines its own version of <em>PI</em> or <em>e</em> and the value is not as precise as the
			one defined in the constants Math.PI or Math.E. Use these constants instead.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_STUTTERED_ASSIGNMENT">
		<ShortDescription>メソッドは ２回続けてローカル変数に値を格納しています。</ShortDescription>
		<LongDescription>メソッド {1} は２回続けてローカル変数に値を格納しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method assigns a value twice in a row in a stuttered way such as
			<code>a = a = 5;</code> This is most probably a cut and paste error where the duplicate
			assignment can be removed.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_USE_ISNAN">
		<ShortDescription>メソッドは Double.NAN と double型の値　を比較しています。</ShortDescription>
		<LongDescription>メソッド {1} は Double.NAN と double　を比較しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method compares a douhle or float to the constant Double.NaN or Float.NaN. You should use
			Double.isNaN(d) or Float.isNaN(f) if a primitive; or d.isNaN() or f.isNaN() if a boxed double, instead.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_USE_BIGDECIMAL_STRING_CTOR">
		<ShortDescription>メソッドは BigDecimalのコンストラクタに double型の値を渡します。</ShortDescription>
		<LongDescription>メソッド {1} は BigDecimalのコンストラクタに double型の値を渡します。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls the BigDecimal constructor that takes a double, and passes a literal double constant value. Since
			the use of BigDecimal is to get better precision than double, by passing a double, you only get the precision of double number
			space. To take advantage of the BigDecimal space, pass the number as a string. </p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_STRINGBUFFER_WITH_EMPTY_STRING">
		<ShortDescription>メソッドは StringBuffer や StringBuilder のコンストラクタに空の文字列を渡しています。</ShortDescription>
		<LongDescription>メソッド {1} は StringBuffer や StringBuilder のコンストラクタに空の文字列を渡しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls the StringBuffer of StringBuilder constructor passing in a constant empty string ("").
			This is the same as calling the default constructor, but makes the code work harder. Consider passing in a
			default size instead.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_EQUALS_ON_ENUM">
		<ShortDescription>メソッドは enumインスタンスの equalsメソッドを呼び出しています。</ShortDescription>
		<LongDescription>メソッド {1} は enumインスタンスの equalsメソッドを呼び出しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls the equals(Object) method on an enum instance. Since enums values are singletons,
			you can use == to safely compare two enum values. In fact, the implementation for Enum.equals does just
			that.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_INVALID_BOOLEAN_NULL_CHECK">
		<ShortDescription>メソッドは Boolean値の nullチェックに 誤ったC++スタイルを使用しています。</ShortDescription>
		<LongDescription>メソッド {1} は　Boolean値の nullチェックに 誤ったC++スタイルを使用しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method attempts to check for null by just refering to the variable name
			as would be done in C++. This ordinarily would be considered a compile error, except the
			variable in question is a Boolean, which does an auto unbox to boolean.</p>
			<pre>
				if (b && b.booleanValue())
			</pre>
			should be
			<pre>
				if ((b != null) && b.booleanValue())
			</pre>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_USE_CHARAT">
		<ShortDescription>メソッドは charAt メソッドと同様のことを行うために、文字配列を取得しています。</ShortDescription>
		<LongDescription>メソッド {1} は charAt メソッドと同様のことを行うために、文字配列を取得しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls the toCharArray method on a String the fetch an array of characters, only
			to retrieve one of those characters by index. It is more performant to just use the charAt method.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_USELESS_TRINARY">
		<ShortDescription>メソッドは true や false へ boolean値をキャストするトライナリ演算子を使用しています。</ShortDescription>
		<LongDescription>メソッド {1} は true や false へ boolean値をキャストするトライナリ演算子を使用しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method tests the value of a boolean and using a ternary operator to return either true or false.
			The ternary operator is completely unecessary, just use the original boolean value.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_SUSPECT_STRING_TEST">
		<ShortDescription>メソッドは 空の文字列を null や 通常の文字列 とは異なる扱いをしています。</ShortDescription>
		<LongDescription>メソッド {1} は空の文字列を null や 通常の文字列 とは異なる扱いをしています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method tests a string, and groups null values with real strings, leaving empty strings as another
			case. This might be perfectly valid, but normally, null strings and empty strings are logically handled the same way,
			and so this test may be flawed.</p>
			<p>Pattern found is one of the following
			<pre>if ((s == null) || (s.length() > 0))</pre> -- did you mean ((s == null) || (s.length() == 0))?
			<pre>if ((s == null) || (s.length() != 0))</pre> -- did you mean ((s == null) || (s.length() == 0))?
			<pre>if ((s != null) && (s.length() == 0))</pre> -- did you mean ((s != null) && (s.length() > 0))?
			or perhaps ((s == null) || (s.length() == 0))?
			</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_USE_STRINGBUILDER_LENGTH">
		<ShortDescription>メソッドは 文字列の長さを取得するために、 StringBuffer または StringBuilder から String へ変換しています。</ShortDescription>
		<LongDescription>メソッド {1} は文字列の長さを取得するために、 StringBuffer または StringBuilder から String へ変換しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls the toString method on a StringBuffer or StringBuilder only to call length() on the resulting
			string. It is faster, and less memory intensive to just call the length method directly on the StringBuffer or StringBuilder
			itself.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_INVALID_CALENDAR_COMPARE">
		<ShortDescription>メソッドは Calendar.before または Calendar.after メソッドに非calendarオブジェクトを渡しています。</ShortDescription>
		<LongDescription>メソッド {1} は Calendar.before または Calendar.after メソッドに非calendarオブジェクトを渡しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method passes a non calendar object to the java.util.Calendar.after or java.util.Calendar.before methods.
			Even though these methods take an Object as a parameter type, only Calendar type objects are supported, otherwise
			false is returned</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_USE_CONTAINSKEY">
		<ShortDescription>メソッドは containsKey を使用せずに、containsを呼ぶために keySet() を呼んでいます。</ShortDescription>
		<LongDescription>メソッド {1} は containsKey を使用せずに、containsを呼ぶために keySet() を呼んでいます。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls mySet.keySet().contains("foo") when mySet.containsKey("foo") is simpler</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_USE_ISEMPTY">
		<ShortDescription>メソッドは isEmpty() を使用せずに、コレクションのサイズが０であるかの確認をしています。</ShortDescription>
		<LongDescription>メソッド {1} は isEmpty() を使用せずに、コレクションのサイズが０であるかの確認をしています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls the size() method on a collection and compares the result to zero to see if the collection
			is empty. For better code clarity, it is better to just use col.isEmpty() or !col.isEmpty()</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_USE_GETPROPERTY">
		<ShortDescription>メソッドは １つのプロパティを取得するために、getProperty ではなく、getProperties を使用しています。</ShortDescription>
		<LongDescription>メソッド {1} は１つのプロパティを取得するために、getProperty ではなく、getProperties を使用しています。</LongDescription>
		<Details>
			<![CDATA[
			<table>
				<tr><td>This method uses</td></tr>
				<tr><td>String prop = System.getProperties().getProperty("foo");</td></tr
				<tr><td>instead of simply using</td></tr>
				<tr><td>String prop = System.getProperty("foo");</td></tr>
			</table>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_SERIALVER_SHOULD_BE_PRIVATE">
		<ShortDescription>クラスは非プライベートとして serialVersionUID を定義しています。</ShortDescription>
		<LongDescription>クラス {0} は非プライベートとして serialVersionUID を定義しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This class defines a static field 'serialVersionUID' to define the serialization
			version for this class. This field is marked as non private. As the serialVersionUID only
			controls the current class, and doesn't effect any derived classes, defining it as non
			private is confusing. It is suggested you change this variable to be private.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_USELESS_CASING">
		<ShortDescription>メソッドは 大文字小文字の変更後に、大文字小文字の区別なしで文字列比較しています。</ShortDescription>
		<LongDescription>メソッド {1} は大文字小文字の変更後に、大文字小文字の区別なしで文字列比較しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method compares two strings with compareToIgnoreCase or equalsIgnoreCase, after having
			called toUpperCase or toLowerCase on the string in question. As you are comparing with out
			concern to case, the toUpperCase or toLowerCase calls are pointless and can be removed.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_NON_ARRAY_PARM">
		<ShortDescription>メソッドは 配列を期待するパラメータに対して非配列オブジェクトを渡しています。</ShortDescription>
		<LongDescription>メソッド {1} は配列を期待するパラメータに対して非配列オブジェクトを渡しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method expects an array to be passed as one of its parameters, but unfortunately defines
			the parameter as Object. This invocation of this method does not pass an array and will throw
			an exception when run.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_EMPTY_CASING">
		<ShortDescription>メソッドは equalsIgnoreCase または compareToIgnoreCase メソッドに空の文字列を渡しています。</ShortDescription>
		<LongDescription>メソッド {1} は equalsIgnoreCase または compareToIgnoreCase メソッドに空の文字列を渡しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method passes the empty string "" to equalsIgnoreCase or compareToIgnoreCase, as the empty string
			is not case sensitive using equals is simpler. It would be even simpler to do a length() == 0 test.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_TEMPORARY_TRIM">
		<ShortDescription>メソッドは 一時的に文字列をトリムしています。</ShortDescription>
		<LongDescription>メソッド {1} は一時的に文字列をトリムしています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls trim() on a String without assigning the new string to another variable.
			It then calls length() or equals on this trimmed string. If trimming the string was important
			for determining it's length of it's equality, it should be trimmed when you actually go to use it.
			It would make more sense to first trim the String, store the trimmed value in a variable, and then
			continue to test and use that trimmed string.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_STRINGBUILDER_IS_MUTABLE">
		<ShortDescription>メソッドは 不変な StringBuilder インスタンスをそれ自身の変数に不必要に格納しています。</ShortDescription>
		<LongDescription>メソッド {1} は不変な StringBuilder インスタンスをそれ自身の変数に不必要に格納しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>このメソッドは StringBuilder.append メソッドを呼び、その結果を同じ StringBuilder 変数へ格納しています。</p>
			<pre>sb = sb.append("foo")</pre>
			<p>StringBuilder は不変なため、不必要です。
			これは StringBuffer についても、同様です。</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_USE_GET0">
		<ShortDescription>メソッドは リストの最初の要素を取得するために、 iterator().next() を使用しています。</ShortDescription>
		<LongDescription>メソッド {1} はリストの最初の要素を取得するために、 iterator().next() を使用しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>このメソッドは、リストの最初の要素を取得するために、 iterator().next() を呼び出しています。
			myList.get(0) を使用する方法がより優れています。</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_DOUBLE_APPENDED_LITERALS">
		<ShortDescription>メソッドは StringBuilderへ引き続いて ２つのリテラル文字列を追加しています。</ShortDescription>
		<LongDescription>メソッド {1} は StringBuilderへ引き続いて ２つのリテラル文字列を追加しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>このメソッドは、StringBuilderへ引き続いて ２つのリテラル文字つを追加指定ます。
			これは、１つのappend呼び出しで行うことが出来、StringBuilderのバッキングストアの中間再分配を回避することが出来ます。</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SPP_NULL_BEFORE_INSTANCEOF">
		<ShortDescription>メソッドは instanceof を呼ぶ前に null参照のチェックを行っています。</ShortDescription>
		<LongDescription>メソッド {1} はinstanceof を呼ぶ前に null参照のチェックを行っています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method checks a reference for null just before seeing if the reference is an instanceof some class.
			Since instanceof will return false for null references, the null check is not needed.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="BAS_BLOATED_ASSIGNMENT_SCOPE">
		<ShortDescription>メソッドは 必要とされるよりも大きなスコープで変数を確保しています。</ShortDescription>
		<LongDescription>メソッド {1} は必要とされるよりも大きなスコープで変数を確保しています。</LongDescription>
		<Details>
			<![CDATA[
			<p><em>このディテクタは、実験中であり、多くの誤検知(FUD(Fear, Uncertainty and Doubt))が発生する可能性があります。</em></p>
			<p>This method assigns a value to a variable in an outer scope compared to where the variable is actually used.
			Assuming this evaluation does not have side effects, the assignment can be moved into the inner scope (if block)
			so that its execution time isn't taken up if the if guard is false. Care should be
			taken however that the right hand side of the assignment does not contain side
			effects that are required to happen, or that changes are not made further down that
			will effect the execution of the assignment when done later on.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SCII_SPOILED_CHILD_INTERFACE_IMPLEMENTOR">
		<ShortDescription>クラスは 無名なスーパークラスのメソッドに頼ることによってインターフェイスを実装しています。</ShortDescription>
		<LongDescription>クラス {0} は無名なスーパークラスのメソッドに頼ることによってインターフェイスを実装しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This class declares that it implements an interface, but does so by relying on methods supplied
			by superclasses, even though those superclasses know nothing about the interface in question. If you wish
			to have the child not implement all the methods of the interface, it would probably be better to declare
			the superclass as implementing the interface, and if that class does not provide all the methods, then declare
			that superclass abstract.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="DWI_DELETING_WHILE_ITERATING">
		<ShortDescription>メソッドは 繰り返しの最中にコレクションの要素を削除しています。</ShortDescription>
		<LongDescription>メソッド {1} は繰り返しの最中にコレクションの要素を削除しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method removes items from a collection using the remove method of the collection, while
			at the same time iterating across the collection. Doing this will invalidate the iterator, and further
			use of it, will cause ConcurrentModificationExceptions to be thrown. To avoid this, the remove
			method of the iterator should be used.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="DWI_MODIFYING_WHILE_ITERATING">
		<ShortDescription>メソッドは 繰り返しの最中にコレクションの要素を変更しています。</ShortDescription>
		<LongDescription>メソッド {1} は繰り返しの最中にコレクションの要素を変更しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method modifies the contents of a collection using the collection api methods, while
			at the same time iterating across the collection. Doing this will invalidate the iterator, and further
			use of it, will cause ConcurrentModificationExceptions to be thrown.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="USS_USE_STRING_SPLIT">
		<ShortDescription>メソッドは 文字列のトークン化を使用してい文字列配列を生成しています。</ShortDescription>
		<LongDescription>メソッド {1} は文字列のトークン化を使用してい文字列配列を生成しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method uses a StringTokenizer to split up a String and then walks thru the
			separated elements and builds an array from these enumerated values. It is simpler
			and easier to use the String.split method.</p>
			<p>PLEASE NOTE: String.split will return an array of 1 element when passed the
			empty string, as opposed to using StringTokenizer which returns false on the first
			hasMoreElements/hasMoreTokens call. So you may need to use</p>
			<pre>
				if (s.length() > 0)
					return s.split(";");
				return new String[0];
			</pre>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SJVU_SUSPICIOUS_JDK_VERSION_USE">
		<ShortDescription>メソッドは rt.jar に存在しないクラスまたはメソッドを使用しています。</ShortDescription>
		<LongDescription>メソッド {1} は クラスがコンパイルされたバージョンの rt.jar に存在しないクラスまたはメソッドを使用しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls a method that does not exist, on a class that does not exist in the jdk that
			this class has been compiled for. This can happen if you compile the class specifying the -source and
			-target options, and use a version that is before the version of the compiler's JDK.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="UAA_USE_ADD_ALL">
		<ShortDescription>メソッドは １つのコレクションの内容を別のコレクションにコピーするために、単純なループを使用しています。</ShortDescription>
		<LongDescription>メソッド {1} は１つのコレクションの内容を別のコレクションにコピーするために、単純なループを使用しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method uses a simple for loop to copy the contents of a set, list, map key/value, array or other collection
			to another collection. It is simpler and more straight forward to just call the addAll method of the destination collection
			passing in the source collection. In the case that the source is an array, you can use Array.asList method to massage the array
			into a collection</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="MRC_METHOD_RETURNS_CONSTANT">
		<ShortDescription>プライベートメソッドは １つの定数値だけを返します。</ShortDescription>
		<LongDescription>プライベートメソッド {1} は１つの定数値だけを返します。</LongDescription>
		<Details>
			<![CDATA[
			<p>This private or static method only returns one constant value. As this method is private or static,
			it's behavior can't be overridden, and thus the return of a constant value seems dubious.
			Either the method should be changed to return no value, or perhaps another return value
			was expected to be returned in another code path in this method.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NCS_NEEDLESS_CUSTOM_SERIALIZATION">
		<ShortDescription>メソッドは デフォルトストリーミング動作を不必要に実装しています。</ShortDescription>
		<LongDescription>メソッド {1} はデフォルトストリーミング動作を不必要に実装しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method implements the Serializable interface by performing the same operations that
			would be done if this method did not exist. Since this is the case, this method is not needed.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="MOM_MISLEADING_OVERLOAD_MODEL">
		<ShortDescription>クラスは インスタンスと静的バージョンの両方のメソッドを “オーバーロード”しています。</ShortDescription>
		<LongDescription>クラス {0} はインスタンスと静的バージョンの両方のメソッドを “オーバーロード”しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This class 'overloads' the same method with both an instance and static version. As the use
			of these two models is different, it will be confusing to the users of these methods.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="EXS_EXCEPTION_SOFTENING_NO_CONSTRAINTS">
		<ShortDescription>制約のないメソッドは チェックされる例外からチェックされない例外へ変換しています。</ShortDescription>
		<LongDescription>制約のないメソッド {1} はチェックされる例外からチェックされない例外へ変換しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method is not constrained by an interface or superclass, but converts a caught checked exception
			to unchecked exception and thrown. It would be more appropriate just throw the checked exception, adding
			the exception to the throws clause of the method.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="EXS_EXCEPTION_SOFTENING_HAS_CHECKED">
		<ShortDescription>制約メソッドは チェックされる例外から、チェックされない例外の代わりに他の許容されたチェックされる例外に変換しています。</ShortDescription>
		<LongDescription>制約メソッド {1} はチェックされる例外から、チェックされない例外の代わりに他の許容されたチェックされる例外に変換しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method's exception signature is constrained by an interface of super class to not throw a
			checked exception that was caught. Therefore this exception was converted to an unchecked exception and
			thrown. It would probably be better to throw the closest checked exception allowed, and to annotate
			the new exception with the original exception using the initial cause field.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="EXS_EXCEPTION_SOFTENING_NO_CHECKED">
		<ShortDescription>制約されたメソッドは チェックされる例外からチェックされない例外へ変換しています。</ShortDescription>
		<LongDescription>制約されたメソッド {1} はチェックされる例外からチェックされない例外へ変換しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method's exception signature is constrained by an interface or super class to not throw
			any checked exceptions. Therefore a caught checked exception was converted to an unchecked exception
			and thrown. However it appears that the class in question is owned by the same author as the constraining
			interface or superclass. Consider changes the signature of this method to include the checked exception.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="CFS_CONFUSING_FUNCTION_SEMANTICS">
		<ShortDescription>メソッドは 変更されたパラメータを返します。</ShortDescription>
		<LongDescription>メソッド {1} は変更されたパラメータを返します。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method appears to modify a parameter, and then return this parameter as the
			methods return value. This will be confusing to callers of this method, as it won't be
			apparent that the 'original' passed in parameter will be changed as well. If the purpose
			of this method is to change the parameter, it would be more clear to change the method to
			a have a void return value. If a return type is required due to interface or superclass contract,
			perhaps a clone of the parameter should be made.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="JAO_JUNIT_ASSERTION_ODDITIES_ACTUAL_CONSTANT">
		<ShortDescription>メソッドは ２つ目の（actual）アサーション・パラメータに定数を渡しています。</ShortDescription>
		<LongDescription>メソッド {1} は２つ目の（actual）アサーション・パラメータに定数を渡しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls assert passing a constant value as the second of the two values. The assert
			method assumes that the expected value is the first parameter, and so it appears that the order
			of values has been swapped here.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="JAO_JUNIT_ASSERTION_ODDITIES_INEXACT_DOUBLE">
		<ShortDescription>メソッドは ２つの浮動小数点数が正確に一致することを確認しています。</ShortDescription>
		<LongDescription>メソッド {1} は２つの浮動小数点数が正確に一致することを確認しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls assert with two doubles or Doubles. Due to the inprecision of doubles, you
			should be using the assert method that takes a range parameter that gives a range of error.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="JAO_JUNIT_ASSERTION_ODDITIES_BOOLEAN_ASSERT">
		<ShortDescription>メソッドは 値が true か false かを確認しています。</ShortDescription>
		<LongDescription>メソッド {1} は値が true か false かを確認しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method asserts that a value is equal to true or false. It is simpler to just
			use assertTrue, or assertFalse, instead.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="JAO_JUNIT_ASSERTION_ODDITIES_IMPOSSIBLE_NULL">
		<ShortDescription>メソッドは オートボクシング値が null値ではないことを確認しています。</ShortDescription>
		<LongDescription>メソッド {1} はオートボクシング値が null値ではないことを確認しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method asserts that a primitive value that was autoboxed into a boxed primitive was not
			null. This will never happen, as primitives are never null, and thus the autoboxed value isn't
			either.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SCA_SUSPICIOUS_CLONE_ALGORITHM">
		<ShortDescription>Cloneメソッドは 元のオブジェクトのメンバーフィールドに新たな値を格納しています。</ShortDescription>
		<LongDescription>Cloneメソッド {1} は元のオブジェクトのメンバーフィールドに新たな値を格納しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method uses a java assert to assure that a certain state is in effect. As this is
			a junit test it makes more sense to either check this condition with a junit assert, or allow
			a following exception to occur.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="WEM_WEAK_EXCEPTION_MESSAGING">
		<ShortDescription>メソッドは 静的メッセージ文字列を使用した例外をスローしています。</ShortDescription>
		<LongDescription>メソッド {1} は静的メッセージ文字列を使用した例外をスローしています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method evaluates a boolean expression and passes that to Assert.assertTrue. It is better
			to pass the two values that are being equated to the Assert.assertEquals method so that the
			junit failure method is more meaningful of the intended test.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SCA_SUSPICIOUS_CLONE_ALGORITHM">
		<ShortDescription>Cloneメソッドは 元のオブジェクトのメンバフィールドに新しい値を格納すしています。</ShortDescription>
		<LongDescription>Cloneメソッド {1} は元のオブジェクトのメンバフィールドに新しい値を格納すしています。</LongDescription>
		<Details>
			<![CDATA[
			<p>The clone method stores a value to a member field of the source object. Normally, all
			changes are made to the cloned object, and given that cloning is almost always considered
			a read-only operation, this seems incorrect.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="WEM_WEAK_EXCEPTION_MESSAGING">
		<ShortDescription>メソッドは 静的なメッセージ文字列と例外をスローします。</ShortDescription>
		<LongDescription>メソッド {1} は静的なメッセージ文字列と例外をスローします。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method creates and throws an exception using a static string as the exceptions message.
			Without any specific context of this particular exception invocation, such as the value of parameters,
			key member variables, or local variables, it may be difficult to infer how this exception occurred. Consider
			adding context to the exception message.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SCSS_SUSPICIOUS_CLUSTERED_SESSION_SUPPORT">
		<ShortDescription>メソッドは setAttributeメソッドを呼び出すことなく、HTTPセッション属性を変更しています。</ShortDescription>
		<LongDescription>メソッド {1} はsetAttributeメソッドを呼び出すことなく、HTTPセッション属性を変更しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method fetches a complex object from an HttpSession object, modifies this object, but does
			not call setAttribute, to inform the application server that this attribute has been changed. This will
			cause this attribute not to be updated in other servers in a clustered environment, as only changes marked
			by a call to setAttribute are replicated.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="LO_LOGGER_LOST_EXCEPTION_STACK_TRACE">
		<ShortDescription>メソッドは ロガーメソッドの最初のパラメータに例外を誤って渡しています。</ShortDescription>
		<LongDescription>メソッド {1} はロガーメソッドの最初のパラメータに例外を誤って渡しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method passes an exception as the first argument to a logger method. The stack
			trace is potentially lost due to the logger emitting the exception using toString(). It
			is better to construct a log message with sufficient context and pass the exception as
			the second argument to capture the stack trace.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="LO_SUSPECT_LOG_CLASS">
		<ShortDescription>メソッドは ロガーを取得する際に、無関係なクラスを指定しています。</ShortDescription>
		<LongDescription>メソッド {1} はロガーを取得する際に、無関係なクラスを指定しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method creates a Logger by passing in a specification for a class that is unrelated
			to the class in which the logger is going to be used. This is likely caused by copy/paste code.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="LO_SUSPECT_LOG_PARAMETER">
		<ShortDescription>コンストラクタは Logger型のパラメータを宣言しています。</ShortDescription>
		<LongDescription>コンストラクタ {1} は Logger型のパラメータを宣言しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This constructor declares a parameter that is a Logger. As loggers are meant to be
			created statically per class, it doesn't make sense that you would pass a Logger from one
			class to another. Declare the Logger static in each class instead.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="LO_STUTTERED_MESSAGE">
		<ShortDescription>メソッドは ロガー内の例外メッセージを繰り返しています。</ShortDescription>
		<LongDescription>メソッド {1} はロガー内の例外メッセージを繰り返しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method uses a logger method that takes an exception, and passes the result of
			the getMessage() method on the exception that occurred as the log message.
			Since you are already passing in the exception, that message is already present in the
			logs, and by passing it in as the message, you are just stuttering information.
			It would be more helpful to provide a hand written message that describes the error in
			this method, possibly including the values of key variables.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="LO_INVALID_FORMATTING_ANCHOR">
		<ShortDescription>Method attempts to log using numbered formatting anchors</ShortDescription>
		<LongDescription>Method {1} attempts to log using numbered formatting anchors</LongDescription>
		<Details>
			<![CDATA[
			<p>This method attempts to use an SLF4J logger to log a parameterized expression using formatting anchors.
			However, slf4j uses simple non numbered anchors such as {}, rather than anchors with digits in them as the
			code uses. Thus no parameter replacement will occur.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="LO_INCORRECT_NUMBER_OF_ANCHOR_PARAMETERS">
		<ShortDescription>メソッドは SLF4J ロギング ステートメントに、誤った数のパラメータを渡しています。</ShortDescription>
		<LongDescription>メソッド {1} はSLF4J ロギング ステートメントに、誤った数のパラメータを渡しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method passes the wrong number of parameters to a slf4j logging method (error, warn, info, debug) based on the number of anchors {} in the
			format string. An additional exception argument is allowed if found.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="IICU_INCORRECT_INTERNAL_CLASS_USE">
		<ShortDescription>クラスは 内部APIクラスに依存しています。</ShortDescription>
		<LongDescription>クラス {0} は内部APIクラスに依存しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This class makes use of internal api classes. As these
			classes are not documented, nor externally released as part of the api, they are subject
			to change or removal. You should not be using these classes.</p>
			Packages that shouldn't be used are:
			<ul>
				<li>com.sun.xxx</li>
				<li>org.apache.xerces.xxx</li>
				<li>org.apache.xalan.xxx</li>
			</ul>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="DSOC_DUBIOUS_SET_OF_COLLECTIONS">
		<ShortDescription>メソッドは コレクションの set メソッドを使用しています。</ShortDescription>
		<LongDescription>メソッド {1} はコレクションの set メソッドを使用しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method creates a set that contains other collections, or a Map whose keySet is
			another collection. As collections tend to calculate hashCode, equals and compareTo by
			iterating the contents of the collection, this can perform poorly.</p>
			<p>In addition, when a set is used, you typically are using it to do 'contains', or 'find'
			type functionality, which seems dubious when done on a collection</p>
			<p>Finally, as a collection is often modified, problems will occur if the collection is
			contained in a set, because the hashCode, equals or compareTo values will change while the
			collection is in the set</p>
			<p>If you wish to maintain a collection of collections, it is probably better to use a List
			as the outer collection</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="BED_BOGUS_EXCEPTION_DECLARATION">
		<ShortDescription>非導出メソッドはスローされない例外をスローすると宣言しています。</ShortDescription>
		<LongDescription>非導出メソッド {1} はスローされない例外をスローすると宣言しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method declares that it throws a checked exception that it does not throw. As this method is
			either a constructor, static method or private method, there is no reason for this method to declare
			the exception in its throws clause, and just causes calling methods to unnecessarily handle an exception
			that will never be thrown. The exception in question should be removed from the throws clause.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="UNNC_UNNECESSARY_NEW_NULL_CHECK">
		<ShortDescription>メソッドは new による確保の結果を確認しています。</ShortDescription>
		<LongDescription>メソッド {1} は new による確保の結果を確認しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method allocations an object with new, and then checks that the object is null
			or non null. As the new operator is guaranteed to either succeed or throw an exception,
			this null check is unnecessary and can be removed.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="DTEP_DEPRECATED_TYPESAFE_ENUM_PATTERN">
		<ShortDescription>クラスは古いスタイルの型安全な列挙パターンを実装しています。</ShortDescription>
		<LongDescription>クラス {0} は古いスタイルの型安全な列挙パターンを実装しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This class appears to implement the old style type safe enum pattern that was used in place of
			real enums. Since this class is compiled with java 1.5 or better, it would be simpler and more
			easy to understand if it was just switched over to an enum.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SMA_STUTTERED_METHOD_ARGUMENTS">
		<ShortDescription>コードは２つの異なる引数に同じ値を渡すメソッドを呼び出しています。</ShortDescription>
		<LongDescription>コード {1} は２つの異なる引数に同じ値を渡すメソッドを呼び出しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls a method passing the same value for two or more of the parameters.
			Often this is a cut/paste bug, but if not, it is confusing why you would pass the same value for two
			different parameters. Perhaps an alternative method that just takes one parameter should be overridden
			in this case.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="TBP_TRISTATE_BOOLEAN_PATTERN">
		<ShortDescription>メソッドは Boolean型に null値を返します。</ShortDescription>
		<LongDescription>メソッド {1} は Boolean型に null値を返します。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method declares that it returns a Boolean value. However the code
			can return a null value. As this is now three values that can be returned;
			Boolean.TRUE, Boolean.FALSE, null; you have changed what a Boolean means.
			It would be clearer to just create a new Enum that has the three values
			you want, and define that the method returns that type.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SUA_SUSPICIOUS_UNINITIALIZED_ARRAY">
		<ShortDescription>メソッドは 初期化されていないようにみえる配列を返します。</ShortDescription>
		<LongDescription>メソッド {1} は初期化されていないようにみえる配列を返します。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method returns an array that was allocated but apparently not initialized. It is
			possible that the caller of this method will do the work of initializing this array, but
			that is not a common pattern, and it is assumed that this array has just been forgotten to
			be initialized.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="ITU_INAPPROPRIATE_TOSTRING_USE">
		<ShortDescription>メソッドは toString()メソッドを呼びだしの結果に対して、アルゴリズム操作を実行しています。</ShortDescription>
		<LongDescription>メソッド {1} は toString()メソッドを呼び出しの結果に対して、アルゴリズム操作を実行しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method calls algorithmic operations on a String that was returned from a toString() method.
			As these methods are for debugging/logging purposes, it shouldn't be the basis of core logic in your code.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="IKNC_INCONSISTENT_HTTP_ATTRIBUTE_CASING">
		<ShortDescription>メソッドは 属性名が大文字小文字の違いしかない同じ HttpSession属性を使用しています。</ShortDescription>
		<LongDescription>メソッド {1} は属性名が大文字小文字の違いしかない同じ HttpSession属性を使用しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method sets or gets an HttpSession attribute with a parmeter name that was used in other locations
			As these methods are for debugging/logging purposes, it shouldn't be the basis of core logic in your code.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="IKNC_INCONSISTENT_HTTP_PARAM_CASING">
		<ShortDescription>メソッドは パラメータ名が大文字小文字の違いしかない同じ HttpRequestパラメータを使用しています。</ShortDescription>
		<LongDescription>メソッド {1} はパラメータ名が大文字小文字の違いしかない同じ HttpRequestパラメータを使用しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method fetches an HttpServletRequest parameter with a parameter name that was used in other locations
			As these methods are for debugging/logging purposes, it shouldn't be the basis of core logic in your code.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="OC_OVERZEALOUS_CASTING">
		<ShortDescription>メソッドは 必要とされるよりも具体的に、右辺のキャストを手動で行なっています。</ShortDescription>
		<LongDescription>メソッド {1} は必要とされるよりも具体的に、右辺のキャストを手動で行なっています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method casts the right hand side of an expression to a class that is more specific than the
			variable on the left hand side of the assignment. The cast only has to be as specific as what the variable
			that is on the left. Using a more specific type on the right hand side just increases cohesion.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="PDP_POORLY_DEFINED_PARAMETER">
		<ShortDescription>メソッドは 適切に機能するのに必要な抽象化よりも、さらに抽象化したパラメータを定義しています。</ShortDescription>
		<LongDescription>メソッド {1} は適切に機能するのに必要な抽象化よりも、さらに抽象化したパラメータを定義しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method defines parameters at a more abstract level than is actually needed to function correctly,
			as the code casts these parameters to more concrete types. Since this method is not derivable, you should
			just define the parameters with the type that is needed.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NSE_NON_SYMMETRIC_EQUALS">
		<ShortDescription>Equalsメソッドは非対称な方法で他のタイプに対して、このオブジェクトを比較しています。</ShortDescription>
		<LongDescription>Equalsメソッド {1} は非対称な方法で他のタイプに対して、このオブジェクトを比較しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This class implements an equals method that compares this object against another type of object.
			This is almost always a bad thing to do, but if it is to be done, you must make sure that the basic
			symmetry rule of equivalence is maintained, that being if a equals b, then b equals a. It does not
			appear that the class that is being compared to this class knows about this class, and doesn't compare itself
			to this.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="CVAA_CONTRAVARIANT_ARRAY_ASSIGNMENT">
		<ShortDescription>メソッドは 反変配列の格納を行なっています。</ShortDescription>
		<LongDescription>メソッド {1} は反変配列の格納を行なっています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method contains a contravariant array assignment. Since arrays are mutable data structures, their use
			must be restricted to covariant or invariant usage</p>

			<pre>
			class A {}
			class B extends A {}

			B[] b = new B[2];
			A[] a = b;
			</pre>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="CVAA_CONTRAVARIANT_ELEMENT_ASSIGNMENT">
		<ShortDescription>メソッドは 反変配列要素の格納を行なっています。</ShortDescription>
		<LongDescription>メソッド {1} は反変配列要素の格納を行なっています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method contains a contravariant array element assignment. Since arrays are mutable
			data structures, their use must be restricted to covariant or invariant usage</p>

			<pre>
			class A {}
			class B extends A {}

			B[] b = new B[2];
			A[] a = b;
			a[0] = new A(); // results in ArrayStoreException (Runtime)
			</pre>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NFF_NON_FUNCTIONAL_FIELD">
		<ShortDescription>シリアライズ可能なクラスに finalな一過性(transient)フィールドが定義されています。</ShortDescription>
		<LongDescription>シリアライズ可能なクラス {0} に finalな一過性(transient)フィールドが定義されています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This serializable class defines a field as both transient and final. As transient fields
			are not serialized across the stream, it is required that some piece of code reinitialize that field
			when it is deserialized. But since constructors aren't called when deserialization, the field is not initialized.
			And since the field is final, no other method can initialize it as well.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SNG_SUSPICIOUS_NULL_FIELD_GUARD">
		<ShortDescription>メソッドは フィールド変数の nullチェックをし、その変数への値の格納を試みています。</ShortDescription>
		<LongDescription>メソッド {1} はフィールド変数の nullチェックをし、その変数への値の格納を試みています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method tests a field to make sure it's not null before executing a conditional block of
			code. However in the conditional block it reassigns the field. It is likely that the guard
			should have been a check to see if the field is null, not that the field was not null.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SNG_SUSPICIOUS_NULL_LOCAL_GUARD">
		<ShortDescription>メソッドは ローカル変数の nullチェックをし、その変数への値の格納を試みています。</ShortDescription>
		<LongDescription>メソッド {1} はローカル変数の nullチェックをし、その変数への値の格納を試みています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method tests a local variable to make sure it's not null before executing a conditional block of
			code. However in the conditional block it reassigns the local variable. It is likely that the guard
			should have been a check to see if the local variable is null, not that the local variable was not null.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="MDM_RUNTIME_EXIT_OR_HALT">
		<ShortDescription>メソッドは Runtime.exit() または Runtime.halt() を呼び出しています。</ShortDescription>
		<LongDescription>メソッド {1} は　{2} を呼び出しています。</LongDescription>
		<Details>
			<![CDATA[
			<p><code>Runtime.exit()</code> または、 <code>Runtime.halt()</code> の呼び出しは、Java仮想マシン全体を停止します。
			これは、適切であるときにのみ実行されるべきです。このような呼び出しは、あなたのコードを他のコードから実行することを、困難または、不可能にします。
			代わりに RuntimeException をスローすることを検討してください。</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="MDM_RUNFINALIZATION">
		<ShortDescription>メソッドは ファイナライズを実行しています。</ShortDescription>
		<LongDescription>メソッド {1} は {2} を呼び出す際にファイナライズを実行しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>Manually triggering finalization can result in serious performance problems and may be masking resource cleanup bugs.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="MDM_BIGDECIMAL_EQUALS">
		<ShortDescription>メソッドは BigDecimal.equals() を呼び出しています。</ShortDescription>
		<LongDescription>メソッド {1} は BigDecimal.equals() を呼び出しています。通常、これは誤りです。</LongDescription>
		<Details>
			<![CDATA[
			<p><code>equals()</code> being called to compare two <code>java.math.BigDecimal</code> numbers. This is normally a mistake, as two <code>BigDecimal</code> objects are only equal if they are equal in both value and scale, so that <i>2.0</i> is not equal to <i>2.00</i>. To compare <code>BigDecimal</code> objects for mathematical equality, use <code>compareTo()</code> instead.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="MDM_INETADDRESS_GETLOCALHOST">
		<ShortDescription>メソッドは InetAddress.getLocalHost() を呼び出しています。</ShortDescription>
		<LongDescription>メソッド {1} は InetAddress.getLocalHost() を呼び出しています。これはセキュリティ脆弱性を持つことになります。</LongDescription>
		<Details>
			<![CDATA[
			<p>Do not call <code>InetAddress.getLocalHost()</code> on multihomed servers. On a multihomed server, <code>InetAddress.getLocalHost()</code> simply returns the IP address associated with the server's internal hostname. This could be any of the network interfaces, which could expose the machine to security risks. Server applications that need to listen on sockets should add configurable properties to define which network interfaces the server should bind.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="MDM_PROMISCUOUS_SERVERSOCKET">
		<ShortDescription>メソッドは 無差別なServerSocketオブジェクトを生成しています。</ShortDescription>
		<LongDescription>メソッド {1} は無差別なServerSocketを生成しています。これはセキュリティ脆弱性を持つことになります。</LongDescription>
		<Details>
			<![CDATA[
			<p><code>全てのネットワークインターフェイス上で接続を受け付ける <code>ServerSocket</code>コンストラクタや <code>ServerSocketFactory.createServerSocket()</code>生成メソッドを使うべきでは有りません。初期状態で、ソケットをリッスンするアプリケーションは、全てのネットワークインターフェイス上で接続の試行を待機します。これはセキュリティ脆弱性を持つことになります。
			<code>バインドするネットワークインターフェイスに対して、特定のローカルアドレスをとる長い形式の ServerSocket</code>コンストラクタや <code>ServerSocketFactory.createServerSocket()</code>生成メソッドだけを使用するべきです。</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="MDM_RANDOM_SEED">
		<ShortDescription>メソッドは 安全ではない Randomオブジェクトを生成しています。</ShortDescription>
		<LongDescription>メソッド {1} は安全ではない Randomオブジェクトを生成しています。これはセキュリティ脆弱性を持つことになります。</LongDescription>
		<Details>
			<![CDATA[
			<p><code>Random()</code> constructor without a seed is insecure because it defaults to easily guessable seed: <code>System.currentTimeMillis()</code>. Initialize seed with <code>Random(SecureRandom.getInstance().generateSeed())</code> or use <code>SecureRandom</code> instead.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="MDM_SECURERANDOM">
		<ShortDescription>メソッドは 非推奨な SecureRandomのメソッドを呼び出しています。</ShortDescription>
		<LongDescription>メソッド {1} は非推奨な SecureRandomのメソッド {2} を呼び出しています。</LongDescription>
		<Details>
			<![CDATA[
			<p><code>SecureRandom()</code> コンストラクタと、 <code>SecureRandom.getSeed()</code> メソッドは非推奨です。
			<code>SecureRandom.getInstance()</code> または、<code>SecureRandom.getInstance().generateSeed()</code> を代わりに呼び出して下さい。</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="MDM_THREAD_PRIORITIES">
		<ShortDescription>メソッドは 不適切なスレッドの優先度を使用しています。</ShortDescription>
		<LongDescription>メソッド {1} は メソッド {2} を呼び出すことで不適切なスレッドの優先度を使用しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>Getting or setting thread priorities is not portable and could cause or mask race conditions.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="MDM_THREAD_YIELD">
		<ShortDescription>メソッドは スレッドを意図的に管理しようとしています。</ShortDescription>
		<LongDescription>メソッド {1} は メソッド {2} を呼び出すことでスレッドを意図的に管理しようとしています。</LongDescription>
		<Details>
			<![CDATA[
			<p>Manual thread scheduling with <code>Thread.sleep()</code> or <code>Thread.yield()</code> has no guaranteed semantics and is often used to mask race conditions.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="MDM_WAIT_WITHOUT_TIMEOUT">
		<ShortDescription>メソッドは タイムアウトなしで、待機します。</ShortDescription>
		<LongDescription>メソッド {1} は {2} を呼び出す際に、タイムアウトなしで、待機します。</LongDescription>
		<Details>
			<![CDATA[
			<p>Calling <code>{2}</code> without timeout could block forever. Consider using a timeout to detect deadlocks or performance problems. Thread.join() Object.wait() Condition.await() Lock.lock() Lock.lockInterruptibly()</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="MDM_THREAD_FAIRNESS">
		<ShortDescription>メソッドは tryLock() を呼ぶことで、ロックの公平性を無視しています。</ShortDescription>
		<LongDescription>メソッド {1} は {2} を呼ぶことで、ロックの公平性を無視しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>Calling <code>Lock.tryLock()</code> or <code>ReentrantLock.tryLock()</code> without a timeout does not honor the lock's fairness setting. If you want to honor the fairness setting for this lock, then use <code>tryLock(0, TimeUnit.SECONDS)</code> which is almost equivalent (it also detects interruption).</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="MDM_SIGNAL_NOT_SIGNALALL">
		<ShortDescription>メソッドは Condition.signalAll() の代わりに Condition.signal() を呼んでいます。</ShortDescription>
		<LongDescription>メソッド {1} は Condition.signalAll() の代わりに Condition.signal() を呼んでいます。</LongDescription>
		<Details>
			<![CDATA[
			<p><code>Condition.signalAll()</code> is prefered over <code>Condition.signal()</code>. Calling <code>signal()</code> only wakes up one thread, meaning that the thread woken up might not be the one waiting for the condition that the caller just satisfied.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="MDM_LOCK_ISLOCKED">
		<ShortDescription>メソッドは ロックがロックされているかを確認しています。</ShortDescription>
		<LongDescription>メソッド {1} は {2} を使用しロックがロックされているかを確認しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>Calling <code>ReentrantLock.isLocked()</code> or <code>ReentrantLock.isHeldByCurrentThread()</code> might indicate race conditions or incorrect locking. These methods are designed for use in debug code or monitoring of the system state, not for synchronization control.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="MDM_STRING_BYTES_ENCODING">
		<ShortDescription>メソッドは 文字エンコーディングの指定をせず、文字列のバイトデータをエンコードしています。</ShortDescription>
		<LongDescription>メソッド {1} は文字エンコーディングの指定をせず、文字列のバイトデータをエンコードしています。</LongDescription>
		<Details>
			<![CDATA[
			<p>The behavior of the <code>String(byte[] bytes)</code> and <code>String.getBytes()</code> is undefined if the string cannot be encoded in the platform's default charset. Instead, use the <code>String(byte[] bytes, String encoding)</code> or <code>String.getBytes(String encoding)></code> constructor which accepts the string's encoding as an argument. Be sure to specify the encoding used for the user's locale.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="MDM_SETDEFAULTLOCALE">
		<ShortDescription>メソッドは Locale.setDefault() を呼び出しています。</ShortDescription>
		<LongDescription>メソッド {1} は Locale.setDefault() を呼び出しています。これは、全てのスレッドのロケールを変更します。</LongDescription>
		<Details>
			<![CDATA[
			<p>Do not use the <code>Locale.setDefault()</code> method to change the default locale. It changes the JVM's default locale for all threads and makes your applications unsafe to threads. It does not affect the host locale. Since changing the JVM's default locale may affect many different areas of functionality, this method should only be used if the caller is prepared to reinitialize locale-sensitive code running within the same Java Virtual Machine, such as the user interface.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="ROOM_REFLECTION_ON_OBJECT_METHODS">
		<ShortDescription>メソッドは java.lang.Object で利用可能なメソッドを呼び出すためにリフレクションを使用しています。</ShortDescription>
		<LongDescription>メソッド {1} は java.lang.Object で利用可能なメソッドを呼び出すためにリフレクションを使用しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method uses reflection to call a method that is defined in java.lang.Object.
			As these methods are always available, it is not necessary to call these methods with
			reflection.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="IPU_IMPROPER_PROPERTIES_USE">
		<ShortDescription>メソッドは プロパティオブジェクトに対して 非文字列値を格納しています。</ShortDescription>
		<LongDescription>メソッド {1} はプロパティオブジェクトに対して 非文字列値を格納しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method places non-String objects into a Properties object. As the Properties object
			is intented to be a String to String map, putting non String objects is wrong, and takes advantage
			of a design flaw in the Properties class by deriving from Hashtable instead of using aggregation.
			If you want a collection that holds other types of objects, use a Hashtable, or better still newer collections
			like HashMap or TreeMap.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="IPU_IMPROPER_PROPERTIES_USE_SETPROPERTY">
		<ShortDescription>メソッドは Properties.setProperty の代わりに Properties.put を使用しています。</ShortDescription>
		<LongDescription>メソッド {1} は Properties.setProperty の代わりに Properties.put を使用しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method uses the inherited method from Hashtable put(String key, Object value) in
			a Properties object. Since the Properties object was intended to be only a String to String
			map, use of the derived put method is discouraged. Use the Properties.setProperty method instead.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="PCAIL_POSSIBLE_CONSTANT_ALLOCATION_IN_LOOP">
		<ShortDescription>メソッドは ループ中で決まった方法でオブジェクトを生成しています。</ShortDescription>
		<LongDescription>メソッド {1} はループ中で決まった方法でオブジェクトを生成しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method allocates an object using the default constructor in a loop, and then
			only uses it in a quasi-static way. It is never assigned to anything that lives outside
			the loop, and could potentially be allocated once outside the loop. Often this can be
			achieved by calling a clear() like method in the loop, to reset the state of the object
			in the loop.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="WOC_WRITE_ONLY_COLLECTION_LOCAL">
		<ShortDescription>メソッドは 生成、初期化したCollectionに対して、参照や取得を行なっていません。</ShortDescription>
		<LongDescription>メソッド {1} が生成、初期化したCollectionに対して、参照や取得は行なっていないません</LongDescription>
		<Details>
			<![CDATA[
			<p>This method creates and initializes a collection but then never access this collection
			to gain information, or fetch items from the collection. It is likely that this collection
			is left over from a past effort, and can be removed.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="WOC_WRITE_ONLY_COLLECTION_FIELD">
		<ShortDescription>クラスは生成、初期化したCollectionに対して、参照や取得を行なっていません。</ShortDescription>
		<LongDescription>クラス {0} は生成、初期化したCollectionに対して、参照や取得を行なっていません。</LongDescription>
		<Details>
			<![CDATA[
			<p>This class creates and initializes a collection as a field but then never access this collection
			to gain information, or fetch items from the collection. It is likely that this collection
			is left over from a past effort, and can be removed.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="UVA_USE_VAR_ARGS">
		<ShortDescription>メソッドは 可変引数ではなく、パラメータの最後に配列を定義しています。</ShortDescription>
		<LongDescription>メソッド {1} は可変引数ではなく、パラメータの最後に配列を定義しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method defines a parameter list that ends with an array. As this class is compiled with
			Java 1.5 or better, this parameter could be defined as a vararg parameter instead, which can be
			more convienent for client developers to use. This is not a bug, per se, just an improvement.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="PUS_POSSIBLE_UNSUSPECTED_SERIALIZATION">
		<ShortDescription>メソッドは 非staticなインナークラスのインスタンスをシリアライズしています。</ShortDescription>
		<LongDescription>メソッド {1} は非staticなインナークラスのインスタンスをシリアライズしています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method serializes an instance of a non-static inner class. Since this class has a
			reference to the containing class, this outer class will be serialized as well. This is often
			not intentional, and will make the amount of data that is serialized much more than is needed.
			If the outer classes is not desired to be serialized, either make the inner class static, or
			pull it out into a separate "first class" class.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SEC_SIDE_EFFECT_CONSTRUCTOR">
		<ShortDescription>メソッドは 副作用のあるコンストラクタを使用しています。</ShortDescription>
		<LongDescription>メソッド {1} は副作用のあるコンストラクタを使用しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>This method creates an object but does not assign this object to any variable or field.
			This implies that the class operates through side effects in the constructor, which is a
			bad pattern to use, as it adds unnecessary coupling. Consider pulling the side effect out of
			the constructor, into a separate method, or into the calling method.</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="SGSU_SUSPICIOUS_GETTER_SETTER_USE">
		<ShortDescription>メソッドは セッターへ同じbeanのゲッターの値を渡しています。</ShortDescription>
		<LongDescription>メソッド {1} はセッターへ同じbeanのゲッターの値を渡しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>このメソッドは、同じ Beanの同じプロパティにセッターで格納するためだけに、Java Beanのプロパティを取得します。
			これは、通常 コピー/ペーストの誤植です。</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="LGO_LINGERING_GRAPHICS_OBJECT">
		<ShortDescription>メソッドは 生成した java.awt.Graphics オブジェクトを破棄していません。</ShortDescription>
		<LongDescription>メソッド {1} は生成した java.awt.Graphics オブジェクトを破棄していません。</LongDescription>
		<Details>
			<![CDATA[
			<p>このメソッドは、java.awt.Graphicsオブジェクトを割り当てますが、使用後に、それを破棄しません。
			ガベージコレクターは短時間に取得される多数の Graphicsオブジェクトをクリーンアップしますが、
			それらの dispose() を明示的に行うことをお勧めします。</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="STB_STACKED_TRY_BLOCKS">
		<ShortDescription>メソッドは 類似の try/catch ブロックをネストしています。</ShortDescription>
		<LongDescription>メソッド {1} は類似の try/catch ブロックをネストしています。</LongDescription>
		<Details>
			<![CDATA[
			<p>このメソッドは、同じタイプの例外をキャッチしている 2つのcatchブロックを相次いで宣言しています。
			またそれらは、一様に例外の同じタイプを投げる。これら2つのcatchブロックは、メソッドを単純化するために1つに結合することができます。</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="CEBE_COMMONS_EQUALS_BUILDER_ISEQUALS">
		<ShortDescription>メソッドは EqualsBuilderのequals()を実行した結果を返しています。</ShortDescription>
		<LongDescription>メソッド {1} は EqualsBuilderのequals()を実行した結果を返しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>このメソッドは、isEqual()メソッドを呼び出す代わりに、EqualsBuilderのequalsメソッドを実行した結果を返しています。</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="CHTH_COMMONS_HASHCODE_BUILDER_TOHASHCODE">
		<ShortDescription>メソッドは HashCodeBuilderのhashCode()を実行した結果を返しています。</ShortDescription>
		<LongDescription>メソッド {1} は　HashCodeBuilderのhashCode()を実行した結果を返しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>このメソッドは、toHashCode()メソッドを呼び出す代わりに、HashCodeBuilderのhashCodeメソッドを実行した結果を返しています。</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="CSBTS_COMMONS_STRING_BUILDER_TOSTRING">
		<ShortDescription>メソッドは ToStringBuilderのappend()の実行をせず、toString()を実行した結果を返しています。</ShortDescription>
		<LongDescription>メソッド {1} は　ToStringBuilderのappend()の実行をせず、toString()を実行した結果を返しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>このメソッドは、append()の実行をせず、ToStringBuilderのtoString()を実行した結果を返しています。</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="CCNE_COMPARE_CLASS_EQUALS_NAME">
		<ShortDescription>メソッドは クラスを比較せず、クラス名を比較しています。</ShortDescription>
		<LongDescription>メソッド {1} はクラスを比較せず、クラス名を比較しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>同じクラスローダーによってロードされている場合、JVM上では、２つのクラスは、同じクラス（従って、同じ型）です。
			そして、同じ完全修飾名を持ちます。 [JVMSpec 1999]

			クラス名の比較は、クラスローダーを無視します。</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="BRPI_BACKPORT_REUSE_PUBLIC_IDENTIFIERS">
		<ShortDescription>メソッドは Backport concurrency utilsを使用しています。</ShortDescription>
		<LongDescription>メソッド {1} は Backport concurrency utilsを使用しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>このクラスは、Backport concurrent utils クラスを使用しています。
			これらのクラスの更新/効率的なバージョンは、JDK5.0以降のバージョンで利用可能であり、
			あなたがJDK1.4以前を対象としている場合のみ、これらのクラスを使用して下さい。</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="CU_CLONE_USABILITY_OBJECT_RETURN">
		<ShortDescription>Cloneメソッドは Objectを返すよう宣言しています。</ShortDescription>
		<LongDescription>Cloneメソッド {1} は Objectを返すよう宣言しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>このクラスは、Cloneableインタフェースを実装していますが、Object型インスタンスを返すように、cloneメソッドを定義しています。
			このメソッドの使用者は、実際の型へキャストする必要があり、これは必要以上に辛いことです。
			このクラスの型になるように戻り値を宣言して下さい。</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="CU_CLONE_USABILITY_MISMATCHED_RETURN">
		<ShortDescription>Cloneメソッドは 自身のクラスとは異なる型を返します。</ShortDescription>
		<LongDescription>Cloneメソッド {1} は 自身のクラスとは異なる型を返します。</LongDescription>
		<Details>
			<![CDATA[
			<p>このクラスは、Cloneableインタフェースを実装していますが、このクラス自身やクラスが実装している任意のインタフェースとは
			異なる型を返す cloneメソッドを定義しています。</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="CU_CLONE_USABILITY_THROWS">
		<ShortDescription>Cloneメソッドは CloneNotSupportedExceptionをスローするよう宣言しています。</ShortDescription>
		<LongDescription>Cloneメソッド {1} は CloneNotSupportedExceptionをスローするよう宣言しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>このクラス歯、Cloneable インタフェースを実装していますが、それでも、CloneNotSupportedException を返すように、
			clone メソッドを定義しています。あなたは、 clone メソッドを実装しているので、問題のメソッドが例外を“スローしない”ことを意味するでしょう。
			そのため、決して発生しない例外を処理する必要があるため、呼び出し元には辛いことです。
			あなたのメソッドから throws 節を削除して下さい。</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="CAAL_CONFUSING_ARRAY_AS_LIST">
		<ShortDescription>メソッドは プリミティブ値の配列に対して Array.asList を呼び出しています。</ShortDescription>
		<LongDescription>メソッド {1} はプリミティブ値の配列に対して Array.asList を呼び出しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>このメソッドは Array.asList 呼び出しへプリミティブ値の配列を渡します。
			配列内のプリミティブ値が自動的に配列内のラッパー型に昇格されないため、asList 呼び出しは、
			ラッパー型のリストに、この配列を変換することは出来ません。従って、配列そのものを１つの項目とするリストが作成されます。
			これは、望まれることは滅多にありません。</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="PSC_PRESIZE_COLLECTIONS">
		<ShortDescription>メソッドは Collection の明示的なサイズ指定をせず確保しています。</ShortDescription>
		<LongDescription>メソッド {1} は Collection の明示的なサイズ指定をせず確保しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>このメソッドは、予めどの程度の要素をコレクションに格納するか知っており(または、少なくとも合理的な推測)、
			不必要にコレクションの再確保を引き起こすにも関わらず、デフォルトのコンストラクタを使用してコレクションを割り当てています。</p>
			]]>
		</Details>
	</BugPattern>"

	<BugPattern type="UMTP_UNBOUND_METHOD_TEMPLATE_PARAMETER">
		<ShortDescription>メソッドが バインドされていないメソッドのテンプレートを宣言しています。</ShortDescription>
		<LongDescription>メソッド {1} が バインドされていないメソッドのテンプレートを宣言しています。</LongDescription>
		<Details>
			<![CDATA[
			<p>このメソッドは、このメソッドの任意のパラメータに拘束されていないメソッド・レベルのテンプレートパラメータを宣言しています。
			したがって、コードの読み手を混乱させるため、テンプレートパラメータは検証の無効や型安全性を追加し、削除出来ます。</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="NPMC_NON_PRODUCTIVE_METHOD_CALL">
		<ShortDescription>メソッドは 非変化メソッドの戻り値を無視します。</ShortDescription>
		<LongDescription>メソッド {1} は 非変化メソッドの戻り値を無視します。</LongDescription>
		<Details>
			<![CDATA[
			<p>このメソッドは、変化させないと仮定された共通メソッドの戻り値を無視しています。
			このメソッドが、実際に呼び出されるオブジェクトを変更しない場合、このメソッドを呼び出す必要がなく、除去することが出来ます。</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="AIOB_ARRAY_INDEX_OUT_OF_BOUNDS">
		<ShortDescription>メソッドは 配列の範囲外の配列要素にアクセスを試みています。</ShortDescription>
		<LongDescription>メソッド {1} は 配列の範囲外の配列要素にアクセスを試みています。</LongDescription>
		<Details>
			<![CDATA[
			<p>このメソッドは、指定された配列の範囲外を示すと判明している 定数インデックスを使用して、 配列要素にアクセスをしています。
			これは、実行時の ArrayIndexOutOfBoundsException の原因となります。</p>
			]]>
		</Details>
	</BugPattern>

	<BugPattern type="AIOB_ARRAY_STORE_TO_NULL_REFERENCE">
		<ShortDescription>メソッドは 領域を確保していない配列へ配列要素の格納を試みています。</ShortDescription>
		<LongDescription>メソッド {1} は 領域を確保していない配列へ配列要素の格納を試みています。</LongDescription>
		<Details>
			<![CDATA[
			<p>このメソッドは、領域を確保していない配列へ配列要素の格納を試みています。</p>
			]]>
		</Details>
	</BugPattern>

	<!-- BugCode -->

	<BugCode abbrev="ISB">非効率な文字列バッファ</BugCode>
	<BugCode abbrev="SCI">同期されたコレクションのIterator</BugCode>
	<BugCode abbrev="CC">循環的複雑度(Cyclomatic Complexity)</BugCode>
	<BugCode abbrev="OCP">パラメータの具象クラスへの依存</BugCode>
	<BugCode abbrev="LII">リストのインデックスアクセス</BugCode>
	<BugCode abbrev="UCC">コレクションの無関係な要素</BugCode>
	<BugCode abbrev="DRE">Runtime Exceptionの宣言</BugCode>
	<BugCode abbrev="CE">クラスの依存</BugCode>
	<BugCode abbrev="LSC">リテラル文字列の比較</BugCode>
	<BugCode abbrev="PCOA">部分的に構築されたオブジェクトへのアクセス</BugCode>
	<BugCode abbrev="DLC">誤った利用をされたリスト・コレクション</BugCode>
	<BugCode abbrev="PL">並列リスト</BugCode>
	<BugCode abbrev="FP">Finalパラメータ</BugCode>
	<BugCode abbrev="ACEM">抽象化クラス内の空メソッド</BugCode>
	<BugCode abbrev="MAC">手動配列コピー</BugCode>
	<BugCode abbrev="FPL">浮動小数点ループ</BugCode>
	<BugCode abbrev="NCMU">非コレクション・メソッドの使用</BugCode>
	<BugCode abbrev="CAO">オートボクシングされたオーバーロードを混乱</BugCode>
	<BugCode abbrev="AFBR">finallyブロック内での異常な戻り</BugCode>
	<BugCode abbrev="SMII">静的メソッドのインスタンス呼び出し</BugCode>
	<BugCode abbrev="STS">偽のスレッド状態</BugCode>
	<BugCode abbrev="NAB">不必要なオートボクシング</BugCode>
	<BugCode abbrev="USBR">リターンの前に不必要な格納</BugCode>
	<BugCode abbrev="COM">コピーされたオーバーライドメソッド</BugCode>
	<BugCode abbrev="ABC">配列ベースのコレクション</BugCode>
	<BugCode abbrev="ODN">孤立したDOMノード</BugCode>
	<BugCode abbrev="AOM">抽象的なオーバーライドされたメソッド</BugCode>
	<BugCode abbrev="CBX">独自生成XML</BugCode>
	<BugCode abbrev="BSB">肥大化した同期ブロック</BugCode>
	<BugCode abbrev="CLI">定数リストインデックス</BugCode>
	<BugCode abbrev="SCR">ずさんなクラスリフレクション</BugCode>
	<BugCode abbrev="AWCBR">配列でラップされた参照による呼び出し</BugCode>
	<BugCode abbrev="SG">低速なGUI</BugCode>
	<BugCode abbrev="NIR">不必要なインスタンスの取得</BugCode>
	<BugCode abbrev="DDC">２つの日付の比較</BugCode>
	<BugCode abbrev="SWCO">不適切な並列オブジェクト上の待機</BugCode>
	<BugCode abbrev="JVR">JDBCベンダーリライアンス</BugCode>
	<BugCode abbrev="PMB">使用メモリの肥大</BugCode>
	<BugCode abbrev="LSYC">ローカル同期されたコレクション</BugCode>
	<BugCode abbrev="FCBL">ローカル変数に出来るフィールド</BugCode>
	<BugCode abbrev="NOS">非所有同期</BugCode>
	<BugCode abbrev="NRTL">再利用されないTaglib</BugCode>
	<BugCode abbrev="S508C">(米)リハビリテーション法 第508条コンプライアンス違反</BugCode>
	<BugCode abbrev="UEC">Enumコレクションの使用</BugCode>
	<BugCode abbrev="SIL">ループ中のSQL</BugCode>
	<BugCode abbrev="NMCS">不必要なメンバー変数のコレクションの同期</BugCode>
	<BugCode abbrev="ITC">継承型のチェック</BugCode>
	<BugCode abbrev="SACM">メソッド内で生成された静的配列</BugCode>
	<BugCode abbrev="PRMC">冗長メソッド呼び出しの可能性</BugCode>
	<BugCode abbrev="UTA">toArrayメソッドの使用</BugCode>
	<BugCode abbrev="LEST">失われた例外スタックトレース</BugCode>
	<BugCode abbrev="UCPM">文字のパタメータ化されたメソッドの使用</BugCode>
	<BugCode abbrev="TR">末端再帰</BugCode>
	<BugCode abbrev="URV">無関係の戻り値</BugCode>
	<BugCode abbrev="PIS">不完全なシリアライズの可能性</BugCode>
	<BugCode abbrev="SCRV">不適切なコンパレータの戻り値</BugCode>
	<BugCode abbrev="SPP">誤りの寄せ集め</BugCode>
	<BugCode abbrev="BAS">肥大化した割当てスコープ</BugCode>
	<BugCode abbrev="SCII">役に立たない子インタフェース実装</BugCode>
	<BugCode abbrev="DWI">繰り返しの間の削除</BugCode>
	<BugCode abbrev="USS">文字列分割の使用</BugCode>
	<BugCode abbrev="SJVU">不適切なJDKバージョンの使用</BugCode>
	<BugCode abbrev="UAA">全て追加を使用</BugCode>
	<BugCode abbrev="MRC">定数を返すメソッド</BugCode>
	<BugCode abbrev="NCS">不必要な独自シリアライズ</BugCode>
	<BugCode abbrev="MOM">誤解を招くオーバーロードモデル</BugCode>
	<BugCode abbrev="EXS">例外のソフト化</BugCode>
	<BugCode abbrev="CFS">紛らわしいセマンティック関数</BugCode>
	<BugCode abbrev="JAO">一般的でないJUnitアサーション</BugCode>
	<BugCode abbrev="SCA">紛らわしいCloneアルゴリズム</BugCode>
	<BugCode abbrev="WEM">弱い例外メッセージ</BugCode>
	<BugCode abbrev="SCSS">不適切なクラスタ化されたセッションサポート</BugCode>
	<BugCode abbrev="LO">一般的でないロガー</BugCode>
	<BugCode abbrev="IICU">誤った内部クラスの使用</BugCode>
	<BugCode abbrev="DSOC">コレクションの疑わしい格納</BugCode>
	<BugCode abbrev="BED">偽の例外宣言</BugCode>
	<BugCode abbrev="UNNC">不必要な新しいNullチェック</BugCode>
	<BugCode abbrev="DTEP">廃止予定の型保証されたEnumパターン</BugCode>
	<BugCode abbrev="SMA">繰り返すメソッド引数</BugCode>
	<BugCode abbrev="TBP">トライステート(３状態) ブールパターン</BugCode>
	<BugCode abbrev="SUA">不適切な初期化されていない配列</BugCode>
	<BugCode abbrev="ITU">不適切な toStringメソッドの使用</BugCode>
	<BugCode abbrev="IKNC">矛盾した Key Name キャスト</BugCode>
	<BugCode abbrev="OC">やり過ぎなキャスト</BugCode>
	<BugCode abbrev="PDP">不完全に定義されたパラメータ</BugCode>
	<BugCode abbrev="NSE">非対称なEquals</BugCode>
	<BugCode abbrev="CVAA">反変配列の割当て</BugCode>
	<BugCode abbrev="NFF">非機能フィールド</BugCode>
	<BugCode abbrev="SNG">不適切なNullガード</BugCode>
	<BugCode abbrev="MDM">何も出力しないメソッド</BugCode>
	<BugCode abbrev="ROOM">オブジェクトメソッドのリフレクション</BugCode>
	<BugCode abbrev="IPU">不適切なプロパティの使用</BugCode>
	<BugCode abbrev="PCAIL">ループ内でオブジェクトの生成</BugCode>
	<BugCode abbrev="WOC">書き込みのみ行うコレクション</BugCode>
	<BugCode abbrev="UVA">可変引数の使用</BugCode>
	<BugCode abbrev="PUS">思いがけず使用されたシリアライズ</BugCode>
	<BugCode abbrev="SEC">副作用コンストラクタ</BugCode>
	<BugCode abbrev="SGSU">不適切なゲッター・セッターの使用</BugCode>
	<BugCode abbrev="LGO">生き続けるグラフィックスオブジェクト</BugCode>
	<BugCode abbrev="STB">tryブロックのネスト</BugCode>
	<BugCode abbrev="CEBE">Commons EqualsBuilder から Equals へ</BugCode>
	<BugCode abbrev="CHTH">Commons HashCodeBuilder から hashCode へ</BugCode>
	<BugCode abbrev="CSBTS">Commons ToStringBuilder から String へ</BugCode>
	<BugCode abbrev="CCNE">クラス名の等価を比較</BugCode>
	<BugCode abbrev="BRPI">Backport concurrentの利用</BugCode>
	<BugCode abbrev="CU">Cloneメソッドの利便性</BugCode>
	<BugCode abbrev="CAAL">Array.asListメソッドの乱用</BugCode>
	<BugCode abbrev="PSC">事前サイズ決定コレクション</BugCode>
	<BugCode abbrev="UMTP">バインドされていないメソッドのテンプレートパラメータ</BugCode>
	<BugCode abbrev="NPMC">非生産的なメソッド呼び出し</BugCode>
	<BugCode abbrev="AIOB">配列インデックス範囲外</BugCode>
</MessageCollection>
